---
title: "geeMIIPW"
output: 
  flexdashboard::flex_dashboard:
  social: menu
source_code: embeded
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(Matrix)
library(shiny)
library(MIIPW)
library(MASS)
library(dplyr)
library(ggplot2)
library(mice)
predGEE<-function(data,idnumber,idvar,fittedObject,time,by,timevalue=NULL){
  data<-data
  if(!inherits(fittedObject,c('ipw','meanscore'))){
    stop('fitted object should be obtained from any of the following functions SIPW,AIPW,miSIPW,meanscore,miAIPW')
  }
  
  ana.model<-as.formula(fittedObject$model)
  
  if(fittedObject$method=='sipw'){
    ana.y<-data[all.vars(ana.model)[1]]
    ana.x<-data[all.vars(ana.model)[-1]]
    #ana.x<-cbind(intercept=1,ana.x)
    ana.x<-cbind(ana.x,ana.y,data[idvar])
    ana.x<-na.omit(ana.x)
    ana.y<-ana.x[c(all.vars(ana.model)[1],idvar)]
    ana.x<-ana.x[!names(ana.x)%in%all.vars(ana.model)[1]]
  }
  
  if(fittedObject$method=='misipw'){
    ana.y<-data[all.vars(ana.model)[1]]
    imputed.x<-list()
    for(i in 1:fittedObject$nimp){
      imputed.x[[i]]<-complete(fittedObject$imputedata,i)
      #print(names(complete(fittedObject$imputedata,i)))
      imputed.x[[i]]<-imputed.x[[i]][all.vars(ana.model)[-1]]
    }
    imputed.x<-Reduce('+',imputed.x)
    imputed.x<-imputed.x/fittedObject$nimp
    ana.x<-cbind.data.frame(imputed.x,ana.y,data[idvar])
    ana.x<-na.omit(ana.x)
    ana.y<-ana.x[c(all.vars(ana.model)[1],idvar)]
    ana.x<-ana.x[!names(ana.x)%in%all.vars(ana.model)[1]]
  }
  if(fittedObject$method=='meanscore'){
    ana.y<-data[all.vars(ana.model)[1]]
    
    imputed.x<-fittedObject$imputedata[all.vars(ana.model)[-1]]
    ana.x<-cbind(imputed.x,ana.y,data[idvar])
    ana.x<-na.omit(ana.x)
    ana.y<-ana.x[c(all.vars(ana.model)[1],idvar)]
    ana.x<-ana.x[!names(ana.x)%in%all.vars(ana.model)[1]]
  }
  
  if(fittedObject$method=='aipw'){
    ana.y<-data[all.vars(ana.model)[1]]
    # imputed.x<-list()
    # for(i in 1:fittedObject$nimp){
    #   imputed.x[[i]]<-complete(fittedObject$imputedata,i)
    # }
    imputed.x<-fittedObject$imputedata[all.vars(ana.model)[-1]]
    ana.x<-cbind(imputed.x,ana.y,data[idvar])
    ana.x<-na.omit(ana.x)
    ana.y<-ana.x[c(all.vars(ana.model)[1],idvar)]
    ana.x<-ana.x[!names(ana.x)%in%all.vars(ana.model)[1]]
  }
  
  if(fittedObject$method=='miaipw'){
    ana.y<-data[all.vars(ana.model)[1]]
    imputed.x<-list()
    for(i in 1:fittedObject$nimp){
      imputed.x[[i]]<-complete(fittedObject$imputedata,i)
      imputed.x[[i]]<-imputed.x[[i]][all.vars(ana.model)[-1]]
    }
    imputed.x<-Reduce('+',imputed.x)/fittedObject$nimp
    ana.x<-cbind(imputed.x,ana.y,data[idvar])
    ana.x<-na.omit(ana.x)
    ana.y<-ana.x[c(all.vars(ana.model)[1],idvar)]
    ana.x<-ana.x[!names(ana.x)%in%all.vars(ana.model)[1]]
  }
  ##############################################################################
  
  iddata.y<-as.matrix(ana.y[ana.y[idvar]==idnumber,][all.vars(ana.model)[1]],ncol=1)
  iddata.x<-ana.x[ana.x[,idvar]==idnumber,]
  iddata.x<-iddata.x[names(iddata.x)!=idvar]
  iddata.x<-cbind(intercept=1,iddata.x)
  
  ##############################################################################
  if(length(iddata.x[,time])>=2){
    #dif<-diff(sort(iddata.x[,time]))
    if(is.null(timevalue)){
      timeseq<-seq(from=iddata.x[,time][length(iddata.x[,time])],by=by,length.out=10)
    }else{
      timeseq<-timevalue
    }
  }else{
    if(is.null(timevalue)){
      timeseq<-seq(from=iddata.x[,time][length(iddata.x[,time])],by=10,length.out=10)
    }else{
      timeseq<-timevalue
    }
  }
  startptime<-max(iddata.x[[time]])
  pseudorow<-Reduce('rbind',replicate(length(timeseq),iddata.x[dim(iddata.x)[1],],simplify = FALSE))
  pseudorow[time]<-timeseq
  mergedata<-rbind(iddata.x,pseudorow)
  
  ##############################################################################
  
  beta.x<-as.matrix(mergedata)
  betafit<-fittedObject$beta
  betacovfit<-fittedObject$betaSand
  fitin<-beta.x%*%as.matrix(betafit,ncol=1)
  fitvar<-beta.x%*%betacovfit%*%t(beta.x)
  fitse<-sqrt(diag(fitvar))
  fitll<-fitin-1.96*fitse
  fitul<-fitin+1.96*fitse
  imputed.yx<-cbind(mergedata,Response=c(iddata.y,rep(NA,nrow(pseudorow))))
  imputed.yx<-cbind(imputed.yx,fitll=fitll,fitin=fitin,fitul=fitul,fitse=fitse)
  names(imputed.yx)[names(imputed.yx)=='Response']<-all.vars(ana.model)[1]
  #colnames(imputed.yx)[-c(1:length(betafit))]<-c('fitll','fitin','fitul','fitse')
  result<-list()
  result$updateData<-imputed.yx
  result$maxTime<-iddata.x[,time][length(iddata.x[,time])]
  #result$startptime<-startptim
  result$dimid<-dim(iddata.x)[1]
  result$timevar<-time
  result$response<-all.vars(ana.model)[1]
  result$direction<-by>0
  #result$analysisModel<-
  return(result)
  
}
predplotGEE<-function(object,scatter=TRUE){
  #object<-prmodel
  predictions_df<-object$updateData
  timevar<-object$timevar
  response<-object$response
  predictions_df<-as.data.frame(predictions_df)
  names(predictions_df)[which(names(predictions_df)==timevar)]<-'Time'
  names(predictions_df)[which(names(predictions_df)==response)]<-'Response'
  nrowiddata<-object$dimid
  lasttime<-object$maxTime
  #predictions_df<-cbind.data.frame(predictions_df,Pred=rep(NA,dim(predictions_df)[1]))
  #predictions_df$Pred<-ifelse(predictions_df['Time']<=lasttime,'Original','Predicted')
  
  
  if(object$direction==T){
    if(isTRUE(scatter)){
      ggplot(predictions_df, aes(x = Time , y = Response )) +
        geom_line(color = "red",linetype = 3) +  # Predicted line
        geom_ribbon(aes(ymin = fitll, ymax =fitul ), fill = "blue", alpha = 0.5) +  # Confidence interval ribbon
        geom_vline(xintercept = object$maxTime, linetype = "dashed", color = "black")+
        #geom_point(aes(y = Response ), color = "brown") + 
        #geom_point(aes(y=yImp.1),color="green")+
        #geom_point(aes(y=yImp.2),color="green")+
        #geom_point(aes(y=yImp.3),color="green")+# Observed data points
        labs(x = timevar, y = response, title = "Prediction using semparametric marginal model") +
        #scale_y_continuous(limits = c(0, 15))+
        theme(panel.background = element_rect(fill = "white", colour = "grey50"))
    }else{
      
      predictions_dfbefore<-predictions_df[1:nrowiddata,]
      predictions_dfafter<-predictions_df[-c(1:nrowiddata),]
      
      ggplot()+
        #scale_x_reverse() +
        geom_point(data=predictions_dfbefore, aes(x = Time , y = Response ))+ 
        geom_line(data=predictions_dfbefore,aes(x = Time , y = Response ),color = "red",linetype = 3)+   # Predicted line
        geom_ribbon(data=predictions_dfafter,aes(y=fitin,ymin = fitll, ymax =fitul,x= Time ), fill = "blue", alpha = 0.5) +
        geom_line(data=predictions_dfafter,aes(y=fitin,x=Time),color="red")+# Confidence interval ribbon
        geom_vline(xintercept = object$maxTime, linetype = "dashed", color = "black")+
        #geom_point(aes(y = Response ), color = "brown") + 
        #geom_point(aes(y=yImp.1),color="green")+
        #geom_point(aes(y=yImp.2),color="green")+
        #geom_point(aes(y=yImp.3),color="green")+# Observed data points
        labs(x = timevar, y = response, title = "Prediction using semparametric marginal model") +
        #scale_y_continuous(limits = c(0, 15))+
        theme(panel.background = element_rect(fill = "white", colour = "grey50"))
    }}else{
      
      if(isTRUE(scatter)){
        ggplot()+
          scale_x_reverse() +
          geom_line(predictions_df, aes(x = Time , y = Response ),color = "red",linetype = 3) +
          #geom_line() +  # Predicted line
          geom_ribbon(aes(ymin = fitll, ymax =fitul ), fill = "blue", alpha = 0.5) +  # Confidence interval ribbon
          geom_vline(xintercept = object$maxTime, linetype = "dashed", color = "black")+
          #geom_point(aes(y = Response ), color = "brown") + 
          #geom_point(aes(y=yImp.1),color="green")+
          #geom_point(aes(y=yImp.2),color="green")+
          #geom_point(aes(y=yImp.3),color="green")+# Observed data points
          labs(x = timevar, y = response, title = "Prediction using semparametric marginal model") +
          #scale_y_continuous(limits = c(0, 15))+
          theme(panel.background = element_rect(fill = "white", colour = "grey50"))
      }else{
        
        predictions_dfbefore<-predictions_df[1:nrowiddata,]
        predictions_dfafter<-predictions_df[-c(1:nrowiddata),]
        
        ggplot()+
          scale_x_reverse() +
          geom_point(data=predictions_dfbefore, aes(x = Time , y = Response ))+ 
          geom_line(data=predictions_dfbefore,aes(x = Time , y = Response ),color = "red",linetype = 3)+   # Predicted line
          geom_ribbon(data=predictions_dfafter,aes(y=fitin,ymin = fitll, ymax =fitul,x= Time ), fill = "blue", alpha = 0.5) +
          geom_line(data=predictions_dfafter,aes(y=fitin,x=Time),color="red")+# Confidence interval ribbon
          geom_vline(xintercept = object$maxTime, linetype = "dashed", color = "black")+
          #geom_point(aes(y = Response ), color = "brown") + 
          #geom_point(aes(y=yImp.1),color="green")+
          #geom_point(aes(y=yImp.2),color="green")+
          #geom_point(aes(y=yImp.3),color="green")+# Observed data points
          labs(x = timevar, y = response, title = "Prediction using semparametric marginal model") +
          #scale_y_continuous(limits = c(0, 15))+
          theme(panel.background = element_rect(fill = "white", colour = "grey50"))
      } 
    }
}
SIPW1<-function(data,formula,id,visit,family,init.beta=NULL,init.alpha=NULL,
                init.phi=NULL,tol=0.001,weights=NULL,corstr='independent',maxit=10,maxvisit=NULL){
  call<-match.call()
  arg_checks <- as.list(match.call())[-1]
  #arg_checks$fomula <-deparse1(formula)
  if(is.null(data)){
    stop("data can't be NULL")
  }
  if(is.null(id)){
    stop("id can't be NULL")
  }
  if(is.null(visit)){
    stop("visit can't be NULL")
  }
  if(is.null(family)){
    stop("family can't be NULL, must be from exponential distribution")
  }
  dt<-data
  stopifnot(id%in%names(dt))
  stopifnot(visit%in%names(dt))
  
  modeldata<-model.frame(formula,dt)
  names(dt)[which(names(dt)==id)]<-'id'
  names(dt)[which(names(dt)==visit)]<-'visit'
  
  dtid<-data.frame(table(dt$id))
  #dtid<-dtid[2]
  dtidvisit<-table(dt$id,dt$visit)
  #if(max(dtid)>maxvisit){
  # stop("Some id's having visits more than",maxvisit)
  #}
  
  uniqueVisit<-unique(dt$visit)
  for(i in 1:length(uniqueVisit)){
    dt[dt$visit==uniqueVisit[i],]$visit<-i
  }
  init.beta<-init.beta;init.alpha<-init.alpha;init.phi<-init.phi
  
  # function to create IPW
  
  #mdata<-data.frame(id=c(rep(1,4),rep(2,4),rep(3,4)),visit=rep(1:4,3),y=rnorm(12,0,1),x1=rnorm(12,2,1),x3=c(1,1,1,1,1,NA,NA,NA,NA,NA,1,1))
  #data<-mdata;id<-'id';visit<-'visit';formula<-y~x1+x3
  # data<-dt;id<-id;visit<-visit;formula<-C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM
  
  if(anyNA(dt)==T){
    ipwlong<-function(data,id,visit,formula)
    {
      dt<-data
      mterms<-all.vars(formula)
      #names(dt)[which(names(dt)==y)]<-'y'
      names(dt)[which(names(dt)==visit)]<-'visit'
      names(dt)[which(names(dt)==id)]<-'id'
      nvisit<-length(unique(dt$visit))
      k1<-which(colnames(dt)=='visit')
      k2<-which(colnames(dt)=='id')
      dt1<-dt[names(dt)%in%c('id','visit',mterms)==T]
      
      dt<-cbind(dt,r.ptrn=as.numeric(apply(dt,1,anyNA)))
      dt$r.ptrn<-ifelse(dt$r.ptrn==0,1,0)
      dtlist<-split(dt,dt$visit)
      mprob1<-NULL
      for(i in 1:nvisit){
        dt2<-dtlist[[i]]
        xptrn<-apply(dt2,2,anyNA)
        xmodel<-mterms
        fxmodel<-xptrn[names(xptrn)%in%mterms]
        fxmodel<-fxmodel[fxmodel==F]
        modeldt2<-formula(paste0('r.ptrn~',paste(names(fxmodel),collapse = '+')))
        m1<-glm(modeldt2,data=dt2,family='binomial')
        mprob1[[i]]<-data.frame(dt2,w=1/m1$fitted.values)
      }
      reddt<-Reduce('rbind',mprob1)
      reddt<-reddt[order(reddt$id),]
      reddt
    }
    wlong<-ipwlong(data=dt,id=id,visit=visit,formula=formula)
    #weights<-rep(1,nrow(data))
    wlong$w<-ifelse(apply(wlong,1,anyNA),0,wlong$w)
    if(sum(wlong$r.ptrn)!=nrow(wlong)){
      weights<-wlong$w
    }else{
      weights<-rep(1,nrow(data))
    }
    
    dt<-na.omit(wlong)
    weights<-dt$w
  }else{
    dt<-dt
    weights<-rep(1,nrow(data))
  }
  
  dat <- model.frame(formula=formula, data=dt, na.action=na.exclude)
  len<-data.frame(table(dt$id))
  nn <- dim(dat)[1]
  corlist<-c("independence", "ar1", "exchangeable", "m-dependent", "unstructured", "fixed", "userdefined")
  cor.match <- charmatch(corstr, corlist)
  
  fmly<-get(family, mode = "function", envir = parent.frame(2))
  fmly<-fmly()
  LinkFun <- fmly$linkfun
  InvLink <- fmly$linkinv
  VarFun <- fmly$variance
  InvLinkDeriv <- fmly$mu.eta
  
  modterms <- terms(formula)
  X <- model.matrix(formula,dat)
  Y <- model.response(dat)
  p <- dim(X)[2]
  W <- Diagonal(x=weights)
  sqrtW <- sqrt(W)
  K <- length(unique(dt$id))
  StdErr <- Diagonal(nn)
  dInvLinkdEta <- Diagonal(nn)
  Resid <- Diagonal(nn)
  
  if(is.null(init.phi)){
    init.phi<-1
  }else{
    init.phi<-init.phi
  }
  phi<-init.phi
  
  linkOfMean <- LinkFun(mean(Y))
  if(is.null(init.beta)){
    init.beta <- rep(0, dim(X)[2])
    init.beta[1] <- linkOfMean
  }else{
    init.beta<-init.beta
  }
  beta <- init.beta
  
  if(is.null(init.alpha)){
    init.alpha<-init.alpha
  }else{
    init.alpha<-init.alpha
  }
  
  #beta<-init.beta
  
  #len <- as.numeric(summary(split(Y, id, drop=T))[,1])
  #BlockDiag <- getBlockDiag(len)$BDiag
  stop <- F
  converged <- F
  count <- 0
  unstable <- F
  phiold <- phi
  betaold <- beta
  alpha<-init.alpha
  R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
  betalist<-list()
  p=0
  while(!stop){
    p <- p+1
    off<-0
    eta <- as.vector(X %*% beta) + off
    
    mu <- InvLink(eta)
    diag(dInvLinkdEta)<-InvLinkDeriv(eta)
    diag(StdErr) <- sqrt(1/VarFun(mu))
    
    #R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
    #R.alpha.inv<-as.matrix(R.alpha.inv)
    UpdatePhi<-function(y,x,vfun,mu,w){
      ymu<-(as.matrix(y-mu,ncol=1,nrow=length(y),byrow=T))
      res<-vfun%*%(w%*%(ymu))
      Newphi<-sum(res*res)/(length(y)-ncol(x))
      Newphi
    }
    phi<-UpdatePhi(y=Y,x=X,vfun=StdErr,mu=mu,w=W)
    phi.new<-phi
    
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=1;corstr = corstr;ni=len$Freq;mv=NULL;id=id$Pig;visit=visit$Time
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=phi;corstr = corstr;ni=len$Freq;mv=NULL;id=dt$id;visit=dt$visit
    
    updateALpha<-function(y,x,vfun,mu,w,phi,corstr,ni,mv=NULL,id,visit){
      nk<-max(ni)
      Alpha<-NULL
      Resid<-vfun%*%((y-mu))
      dt2<-cbind.data.frame(Res=as.vector(Resid),id=id,visit=visit)
      Ralpha<-matrix(1,ncol=nk,nrow=nk)
      ResidMatlist<-list()
      length(ResidMatlist)<-length(ni)
      for(i in 1:length(ResidMatlist)){
        a<-rep(NA,nk)
        dt1<-dt2[dt2$id==unique(dt2$id)[1],]
        a[c(which(c(1:nk)%in%dt1$visit==T))]<-dt1$Res
        a[is.na(a)]<-0
        ResidMatlist[[i]]<-triu(a%*%t(a))
      }
      resMAtsum<-Reduce('+',ResidMatlist)
      
      if(corstr=='fixed'){
        Ralpha<-Ralpha.fixed
      }else if(corstr=="independent"){
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-0
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
        
      }else if(corstr=='unstructured'){
        Ralpha<-resMAtsum/((sum(ni)-ncol(x))*phi)
        diag(Ralpha)<-1
        #ResidNa<-bdiag(ResidMatlist)
        #ResidNa2<-band(ResidNa,k1=1,k2=dim(ResidNa)[2])
        
      }else if(corstr=='exchangeable'){
        Alpha<-(sum(resMAtsum)-sum(diag(resMAtsum)))/(phi*(sum(ni*ni)-sum(ni)-ncol(x)))
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }else if(corstr=='AR-1'){
        Alpha<-(sum(triu(resMAtsum,k=1)))/((sum(ni-1)-ncol(x))*phi)
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha^(abs(i-j))
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }
      Ralpha
    }
    ralpha<-updateALpha(y=Y,x=X,vfun=StdErr,mu=mu,w=W,phi=phi,corstr = corstr,ni=len$Freq,mv=NULL,id=dt$id,visit=dt$visit)
    ralpha<-ralpha*phi
    ralpha.list<-list()
    blockdiag<-c()
    for(i in 1:length(unique(dt$id))){
      
      dt1<-dt[dt$id==unique(dt$id)[i],]
      ralpha.list[[i]]<-ginv(as.matrix(ralpha[c(dt1$visit),c(dt1$visit)]))
      blockdiag[i]<-length(dt1$id)
    }
    R.alpha.inv<-(bdiag(ralpha.list))
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;D=dInvLinkdEta;Ralpha=R.alpha.inv;beta=beta
    updateBeta<-function(y,x,vfun,mu,w,D,Ralpha,beta){
      hess<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%D%*%w%*%x
      u<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%w%*%as.matrix(y-mu)
      Newbeta<-beta+solve(as.matrix(hess),u)
      rslt<-list()
      rslt$Newbeta<-Newbeta
      rslt$hess<-hess
      rslt
    }
    Beta<-updateBeta(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta)
    beta<-Beta$Newbeta
    
    R.alpha.inv<-as.matrix(R.alpha.inv)
    phiold <- phi
    
    if( max(abs((beta - betaold)/(beta+.Machine$double.eps ))) < tol ){converged <- T; stop <- T}
    if(p >= maxit){stop <- T}
    
    betalist[[p]]<-beta
    betaold<-beta
  }
  eta <- as.vector(X %*% beta)
  mu <- InvLink(eta)
  diag(dInvLinkdEta)<-InvLinkDeriv(eta)
  diag(StdErr) <- sqrt(1/VarFun(mu))
  updateSandW<-function(y,x,vfun,mu,w,D,Ralpha,beta,hessmat,blockdiag){
    blockmat<-function(blen,xmat){
      index<-blen
      xmat1<-xmat
      matlist<-list()
      for(i in 1:(length(blen)-1)){
        xmat2<-xmat1[1:blen[i],1:blen[i]]
        matlist[[i]]<-xmat2
        xmat1<-xmat1[-c(1:blen[i]),-c(1:blen[i])]
      }
      matlist[[length(blen)]]<-xmat1
      bmat<-bdiag(matlist)
      bmat
      
    }
    Blockdiag<-blockmat(blen=blockdiag,xmat=as.matrix(y-mu)%*%t(as.matrix(y-mu)))
    
    sigmahat<-Blockdiag
    usand<-t(x)%*%t(D)%*%vfun%*%Ralpha%*%vfun%*%w%*%sigmahat%*%w%*%vfun%*%Ralpha%*%vfun%*%D%*%x
    hessmat<-as.matrix(hessmat)
    upSandwich<-t(solve(hessmat,usand))
    #upSandwich<-upSandwich%*%solve(hessmat)
    upSandwich<-t(solve(t(hessmat),upSandwich))
    upSandwich
  }
  betaSand<-updateSandW(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta,
                        hessmat = Beta$hess,blockdiag=blockdiag)
  reslt<-list()
  reslt$call<-call
  reslt$beta<-beta
  reslt$niter<-p
  reslt$betalist<-betalist
  reslt$Ralpha<-ralpha/phi
  reslt$weight<-W
  reslt$mu<-mu
  reslt$y<-Y
  reslt$phi<-phi
  reslt$hessian<-Beta$hess
  reslt$betaSand<-betaSand
  reslt$model<-deparse1(formula)
  reslt$method<-"sipw"
  class(reslt) <- "ipw"
  return(reslt)
}

miSIPW1<-function(data,formula,id,visit,family,init.beta=NULL,init.alpha=NULL,
                  init.phi=NULL,tol=0.001,weights=NULL,corstr='independent',maxit=50,m=2,pMat,method=NULL){
  call<-match.call()
  arg_checks <- as.list(match.call())[-1]
  arg_checks$fomula <-deparse(formula)
  if(is.null(data)){
    stop("data can't be NULL")
  }
  if(is.null(id)){
    stop("id can't be NULL")
  }
  if(is.null(visit)){
    stop("visit can't be NULL")
  }
  if(is.null(family)){
    stop("family can't be NULL, must be from exponential distribution")
  }
  dt<-data
  stopifnot(id%in%names(dt))
  stopifnot(visit%in%names(dt))
  
  
  modeldata<-model.frame(formula,dt)
  names(dt)[which(names(dt)==id)]<-'id'
  names(dt)[which(names(dt)==visit)]<-'visit'
  dtid<-data.frame(table(dt$id))[2]
  dtidvisit<-table(dt$id,dt$visit)
  # if(max(dtid)>maxvisit){
  # stop("Some id's having visits more than",maxvisit)
  #}
  uniqueVisit<-unique(dt$visit)
  for(i in 1:length(uniqueVisit)){
    dt[dt$visit==uniqueVisit[i],]$visit<-i
  }
  init.beta<-init.beta;init.alpha<-init.alpha;init.phi<-init.phi
  
  
  # function to create IPW
  
  #mdata<-data.frame(id=c(rep(1,4),rep(2,4),rep(3,4)),visit=rep(1:4,3),y=rnorm(12,0,1),x1=rnorm(12,2,1),x3=c(1,1,1,1,1,NA,NA,NA,NA,NA,1,1))
  #data<-mdata;id<-'id';visit<-'visit';formula<-y~x1+x3
  #data<-dt;id<-'id';visit<-'visit';formula<-C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM
  #pMat<-make.predictorMatrix(data[names(data)%in%all.vars(formula)]);m=1;method=NULL
  if(anyNA(dt)==T){
    misipwlong<-function(data,id,visit,formula)
    {
      dt<-data
      mterms<-all.vars(formula)
      #names(dt)[which(names(dt)==y)]<-'y'
      names(dt)[which(names(dt)==visit)]<-'visit'
      names(dt)[which(names(dt)==id)]<-'id'
      nvisit<-length(unique(dt$visit))
      k1<-which(colnames(dt)=='visit')
      k2<-which(colnames(dt)=='id')
      dt1<-dt[names(dt)%in%c('id','visit',mterms)==T]
      
      dt<-cbind(dt,r.ptrn.y=as.numeric(apply(dt[names(dt)==mterms[1]],1,anyNA)),r.ptrn.x=as.numeric(apply(dt[names(dt)%in%mterms[-1]],1,anyNA)))
      dt$r.ptrn.y<-ifelse(dt$r.ptrn.y==0,1,0)
      dt$r.ptrn.x<-ifelse(dt$r.ptrn.x==0,1,0)
      dtlist<-split(dt,dt$visit)
      mprob1<-NULL
      for(i in 1:nvisit){
        dt2<-dtlist[[i]]
        xptrn<-apply(dt2,2,anyNA)
        xmodel<-mterms
        fxmodel<-xptrn[names(xptrn)%in%mterms]
        fxmodel<-fxmodel[fxmodel==F]
        dt2new<-dt2[names(dt2)%in%mterms]
        micemodel<-mice::mice(
          data=dt2new,
          m=m,
          method=method,
          predictorMatrix=pMat,
          ignore=NULL,printFlag = F
          
        )
        completeList<-complete(micemodel,1)
        #names(dt2)[names(dt2)%in%names(fxmodel)]<-names(completeList)[names(dt2)%in%names(fxmodel)]
        #dt2[names(dt2)%in%mterms]<-completeList
        modeldt2<-formula(paste0('r.ptrn.y~',paste(names(fxmodel),collapse = '+')))
        m1<-glm(modeldt2,data=dt2,family='binomial')
        dt2<-data.frame(dt2,w=m1$fitted.values)
        for(j in 1:length(dt2$id)){
          if(dt2$r.ptrn.y[j]==1){
            dt2$w[j]<-1/dt2$w[j]
          }else{
            dt2$w[j]<-0
          }
        }
        #dt2$w<-sapply(dt2$r.ptrn,dt2$w,1-dt$w)
        mprob1[[i]]<-dt2
      }
      reddt<-Reduce('rbind',mprob1)
      reddt<-reddt[order(reddt$id),]
      reddt
    }
    wlong<-misipwlong(data=dt,id=id,visit=visit,formula=formula)
    #weights<-rep(1,nrow(data))
    
    wlong[all.vars(formula)]<-dt[all.vars(formula)]
    pMat1=make.predictorMatrix(wlong[names(wlong)%in%all.vars(formula)[-1]])
    wlongMice<-mice(
      data=wlong,
      m=m,
      method=NULL,
      predictorMatrix=pMat1,
      ignore=NULL,printFlag = F
    )
    #cwlongMice<-complete(wlongMice)
    imputeId<-list()
    for(i in 1:m){
      imputeIdm<-complete(wlongMice,action=i)
      imputeId[[i]]<-imputeIdm[imputeIdm$r.ptrn.x==0,]
    }
    
    ######################################
    nIdm<-nrow(imputeId[[1]])
    imputeId<-Reduce('rbind',imputeId)
    idmat<-matrix(imputeId$id,nrow=nIdm)
    seqId<-seq(max(unique(wlong$id))+1,max(unique(wlong$id))+(ncol(idmat)-1)*length(unique(idmat[,1])))
    unFisrt<-rep(data.frame(table(idmat[,1]))$Freq,(ncol(idmat)-1))
    repseqId<-list()
    for(l in 1:length(seqId)){
      repseqId[[l]]<-rep(seqId[l],unFisrt[l])
    }
    repseqId<-unlist(repseqId)
    
    imputeId$id[-c(1:nIdm)]<-repseqId
    
    ########################################
    
    
    
    imputeId$w<-imputeId$w/m
    wlong<-rbind(wlong,imputeId)
    wlong$w<-ifelse(apply(wlong,1,anyNA),0,wlong$w)
    
    
    dt<-na.omit(wlong)
    weights<-na.omit(wlong)$w
  }else{
    dt<-dt
    weights<-rep(1,nrow(data))
  }
  dat <- model.frame(formula=formula, data=dt, na.action=na.pass)
  dat<-na.omit(dat)
  len<-data.frame(table(dt$id))
  nn <- dim(dat)[1]
  corlist<-c("independence", "ar1", "exchangeable", "m-dependent", "unstructured", "fixed", "userdefined")
  cor.match <- charmatch(corstr, corlist)
  
  fmly<-get(family, mode = "function", envir = parent.frame(2))
  fmly<-fmly()
  LinkFun <- fmly$linkfun
  InvLink <- fmly$linkinv
  VarFun <- fmly$variance
  InvLinkDeriv <- fmly$mu.eta
  
  modterms <- terms(formula)
  X <- model.matrix(formula,dat)
  Y <- model.response(dat)
  p <- dim(X)[2]
  W <- Diagonal(x=weights)
  sqrtW <- sqrt(W)
  K <- length(unique(dt$id))
  StdErr <- Diagonal(nn)
  dInvLinkdEta <- Diagonal(nn)
  Resid <- Diagonal(nn)
  
  if(is.null(init.phi)){
    init.phi<-1
  }else{
    init.phi<-init.phi
  }
  phi<-init.phi
  linkOfMean <- LinkFun(mean(Y))
  if(is.null(init.beta)){
    init.beta <- rep(0, dim(X)[2])
    init.beta[1] <- linkOfMean
  }else{
    init.beta<-init.beta
  }
  beta <- init.beta
  if(is.null(init.alpha)){
    init.alpha<-init.alpha
  }else{
    init.alpha<-init.alpha
  }
  #beta<-init.beta
  #len <- as.numeric(summary(split(Y, id, drop=T))[,1])
  #BlockDiag <- getBlockDiag(len)$BDiag
  stop <- F
  converged <- F
  count <- 0
  unstable <- F
  phiold <- phi
  kbeta <- beta
  alpha<-init.alpha
  R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
  betalist<-list()
  p=0
  while(!stop){
    p <- p+1
    off<-0
    eta <- as.vector(X %*% beta) + off
    
    mu <- InvLink(eta)
    diag(dInvLinkdEta)<-InvLinkDeriv(eta)
    diag(StdErr) <- sqrt(1/VarFun(mu))
    
    #R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
    #R.alpha.inv<-as.matrix(R.alpha.inv)
    y=Y;x=X;vfun=StdErr;mu=mu;w=W
    UpdatePhi<-function(y,x,vfun,mu,w){
      ymu<-(as.matrix(y-mu,ncol=1,nrow=length(y),byrow=T))
      res<-vfun%*%(w%*%(ymu))
      Newphi<-sum(res*res)/(length(y)-ncol(x))
      Newphi
    }
    phi.new<-UpdatePhi(y=Y,x=X,vfun=StdErr,mu=mu,w=W)
    phi<-phi.new
    
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=1;corstr = corstr;ni=len$Freq;mv=NULL;id=id$Pig;visit=visit$Time
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=phi;corstr = corstr;ni=len$Freq;mv=NULL;id=dt$id;visit=dt$visit
    
    updateALpha<-function(y,x,vfun,mu,w,phi,corstr,ni,mv=NULL,id,visit){
      nk<-max(ni)
      Alpha<-NULL
      Resid<-vfun%*%((y-mu))
      dt2<-cbind.data.frame(Res=as.vector(Resid),id=id,visit=visit)
      Ralpha<-matrix(1,ncol=nk,nrow=nk)
      ResidMatlist<-list()
      length(ResidMatlist)<-length(ni)
      for(i in 1:length(ResidMatlist)){
        a<-rep(NA,nk)
        dt1<-dt2[dt2$id==unique(dt2$id)[1],]
        a[c(which(c(1:nk)%in%dt1$visit==T))]<-dt1$Res
        a[is.na(a)]<-0
        ResidMatlist[[i]]<-triu(a%*%t(a))
      }
      resMAtsum<-Reduce('+',ResidMatlist)
      
      if(corstr=='fixed'){
        Ralpha<-Ralpha.fixed
      }else if(corstr=="independent"){
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-0
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
        
      }else if(corstr=='unstructured'){
        Ralpha<-resMAtsum/((sum(ni)-ncol(x))*phi)
        diag(Ralpha)<-1
        #ResidNa<-bdiag(ResidMatlist)
        #ResidNa2<-band(ResidNa,k1=1,k2=dim(ResidNa)[2])
        
      }else if(corstr=='exchangeable'){
        Alpha<-(sum(resMAtsum)-sum(diag(resMAtsum)))/(phi*(sum(ni*ni)-sum(ni)-ncol(x)))
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }else if(corstr=='AR-1'){
        Alpha<-(sum(triu(resMAtsum,k=1)))/((sum(ni-1)-ncol(x))*phi)
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha^(abs(i-j))
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }
      Ralpha
    }
    ralpha<-updateALpha(y=Y,x=X,vfun=StdErr,mu=mu,w=W,phi=phi,corstr = corstr,ni=len$Freq,mv=NULL,id=na.omit(dt)$id,visit=na.omit(dt)$visit)
    ralpha<-ralpha*phi
    ralpha.list<-list()
    blockdiag<-c()
    for(i in 1:length(unique(dt$id))){
      
      dt1<-dt[dt$id==unique(dt$id)[i],]
      ralpha.list[[i]]<-ginv(as.matrix(ralpha[c(dt1$visit),c(dt1$visit)]))
      blockdiag[i]<-length(dt1$id)
    }
    R.alpha.inv<-(bdiag(ralpha.list))
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;D=dInvLinkdEta;Ralpha=R.alpha.inv;beta=beta
    updateBeta<-function(y,x,vfun,mu,w,D,Ralpha,beta){
      hess<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%D%*%w%*%x
      u<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%w%*%as.matrix(y-mu)
      Newbeta<-beta+solve(as.matrix(hess),u)
      rslt<-list()
      rslt$Newbeta<-Newbeta
      rslt$hess<-hess
      rslt
    }
    Beta<-updateBeta(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta)
    betaNew<-Beta$Newbeta
    phi <- phi.new
    R.alpha.inv<-as.matrix(R.alpha.inv)
    phiold <- phi
    beta<-betaNew
    if( max(abs((beta - kbeta)/(beta+.Machine$double.eps ))) < tol ){converged <- T; stop <- T}
    if(p >= maxit){stop <- T}
    
    betalist[[p]]<-betaNew
    betaold<-beta
  }
  eta <- as.vector(X %*% beta)
  mu <- InvLink(eta)
  diag(dInvLinkdEta)<-InvLinkDeriv(eta)
  diag(StdErr) <- sqrt(1/VarFun(mu))
  updateSandW<-function(y,x,vfun,mu,w,D,Ralpha,beta,hessmat,blockdiag){
    blockmat<-function(blen,xmat){
      index<-blen
      xmat1<-xmat
      matlist<-list()
      for(i in 1:(length(blen)-1)){
        xmat2<-xmat1[1:blen[i],1:blen[i]]
        matlist[[i]]<-xmat2
        xmat1<-xmat1[-c(1:blen[i]),-c(1:blen[i])]
      }
      matlist[[length(blen)]]<-xmat1
      bmat<-bdiag(matlist)
      bmat
      
    }
    Blockdiag<-blockmat(blen=blockdiag,xmat=as.matrix(y-mu)%*%t(as.matrix(y-mu)))
    
    sigmahat<-Blockdiag
    usand<-t(x)%*%t(D)%*%vfun%*%Ralpha%*%vfun%*%w%*%sigmahat%*%w%*%vfun%*%Ralpha%*%vfun%*%D%*%x
    hessmat<-as.matrix(hessmat)
    upSandwich<-t(solve(hessmat,usand))
    #upSandwich<-upSandwich%*%solve(hessmat)
    upSandwich<-t(solve(t(hessmat),upSandwich))
    upSandwich
  }
  betaSand<-updateSandW(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta,
                        hessmat = Beta$hess,blockdiag=blockdiag)
  reslt<-list()
  reslt$call<-call
  reslt$beta<-beta
  reslt$niter<-p
  reslt$betalist<-betalist
  reslt$Ralpha<-ralpha/phi
  reslt$weight<-W
  reslt$mu<-mu
  reslt$y<-Y
  reslt$phi<-phi
  reslt$hessian<-Beta$hess
  reslt$betaSand<-betaSand
  reslt$imputedata<-wlongMice
  reslt$nimp<-m
  reslt$model<-deparse1(formula)
  reslt$method<-"misipw"
  class(reslt) <- "ipw"
  return(reslt)
}

miAIPW1<-function(data,formula,id,visit,family,init.beta=NULL,init.alpha=NULL,
                 init.phi=NULL,tol=0.001,weights=NULL,corstr='independent',maxit=50,m=2,pMat,method=NULL){
  call<-match.call()
  arg_checks <- as.list(match.call())[-1]
  arg_checks$fomula <-deparse(formula)
  if(is.null(data)){
    stop("data can't be NULL")
  }
  if(is.null(id)){
    stop("id can't be NULL")
  }
  if(is.null(visit)){
    stop("visit can't be NULL")
  }
  if(is.null(family)){
    stop("family can't be NULL, must be from exponential distribution")
  }
  dt<-data
  stopifnot(id%in%names(dt))
  stopifnot(visit%in%names(dt))
  
  
  modeldata<-model.frame(formula,dt)
  names(dt)[which(names(dt)==id)]<-'id'
  names(dt)[which(names(dt)==visit)]<-'visit'
  
  dtid<-data.frame(table(dt$id))[2]
  dtidvisit<-table(dt$id,dt$visit)
  #if(max(dtid)>maxvisit){
  # stop("Some id's having visits more than",maxvisit)
  #}
  uniqueVisit<-unique(dt$visit)
  for(i in 1:length(uniqueVisit)){
    dt[dt$visit==uniqueVisit[i],]$visit<-i
  }
  init.beta<-init.beta;init.alpha<-init.alpha;init.phi<-init.phi
  
  # function to create IPW
  
  #mdata<-data.frame(id=c(rep(1,4),rep(2,4),rep(3,4)),visit=rep(1:4,3),y=rnorm(12,0,1),x1=rnorm(12,2,1),x3=c(1,1,1,1,1,NA,NA,NA,NA,NA,1,1))
  #data<-mdata;id<-'id';visit<-'visit';formula<-y~x1+x3
  #data<-dt;id<-'id';visit<-'visit';formula<-C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM
  #pMat<-make.predictorMatrix(data[names(data)%in%all.vars(formula)]);m=1;method=NULL
  if(anyNA(dt)==T){
    miaipwlong<-function(data,id,visit,formula)
    {
      dt<-data
      mterms<-all.vars(formula)
      #names(dt)[which(names(dt)==y)]<-'y'
      names(dt)[which(names(dt)==visit)]<-'visit'
      names(dt)[which(names(dt)==id)]<-'id'
      nvisit<-length(unique(dt$visit))
      k1<-which(colnames(dt)=='visit')
      k2<-which(colnames(dt)=='id')
      dt1<-dt[names(dt)%in%c('id','visit',mterms)==T]
      
      dt<-cbind(dt,r.ptrn=as.numeric(apply(dt,1,anyNA)))
      dt$r.ptrn<-ifelse(dt$r.ptrn==0,1,0)
      dtlist<-split(dt,dt$visit)
      mprob1<-NULL
      for(i in 1:nvisit){
        dt2<-dtlist[[i]]
        xptrn<-apply(dt2,2,anyNA)
        xmodel<-mterms
        fxmodel<-xptrn[names(xptrn)%in%mterms]
        fxmodel<-fxmodel[fxmodel==F]
        dt2new<-dt2[names(dt2)%in%mterms]
        micemodel<-mice::mice(
          data=dt2new,
          m=m,
          method=method,
          predictorMatrix=pMat,
          ignore=NULL,printFlag = F
          
        )
        completeList<-complete(micemodel,1)
        #names(dt2)[names(dt2)%in%names(fxmodel)]<-names(completeList)[names(dt2)%in%names(fxmodel)]
        dt2[names(dt2)%in%mterms]<-completeList
        modeldt2<-formula(paste0('r.ptrn~',paste(names(fxmodel),collapse = '+')))
        m1<-glm(modeldt2,data=dt2,family='binomial')
        dt2<-data.frame(dt2,w=m1$fitted.values)
        for(j in 1:length(dt2$id)){
          if(dt2$r.ptrn[j]==1){
            dt2$w[j]<-1/dt2$w[j]
          }else{
            dt2$w[j]<-1/(1-dt2$w[j])
          }
        }
        #dt2$w<-sapply(dt2$r.ptrn,dt2$w,1-dt$w)
        mprob1[[i]]<-dt2
      }
      reddt<-Reduce('rbind',mprob1)
      reddt<-reddt[order(reddt$id),]
      reddt
    }
    wlong<-miaipwlong(data=dt,id=id,visit=visit,formula=formula)
    #weights<-rep(1,nrow(data))
    wlong[all.vars(formula)]<-dt[all.vars(formula)]
    ##
    pMat1=make.predictorMatrix(wlong[names(wlong)%in%all.vars(formula)])
    wlongMice<-mice(
      data=wlong,
      m=m,
      method=NULL,
      predictorMatrix=pMat1,
      ignore=NULL,printFlag = F
    )
    #cwlongMice<-complete(wlongMice)
    imputeId<-list()
    for(i in 1:m){
      imputeIdm<-complete(wlongMice,action=i)
      
      imputeId[[i]]<-imputeIdm[imputeIdm$r.ptrn==0,]
    }
    
    nIdm<-nrow(imputeId[[1]])
    imputeId<-Reduce('rbind',imputeId)
    idmat<-matrix(imputeId$id,nrow=nIdm)
    seqId<-seq(max(unique(wlong$id))+1,max(unique(wlong$id))+(ncol(idmat)-1)*length(unique(idmat[,1])))
    unFisrt<-rep(data.frame(table(idmat[,1]))$Freq,(ncol(idmat)-1))
    repseqId<-list()
    for(l in 1:length(seqId)){
      repseqId[[l]]<-rep(seqId[l],unFisrt[l])
    }
    repseqId<-unlist(repseqId)
    
    imputeId$id[-c(1:nIdm)]<-repseqId
    
    imputeId$w<-imputeId$w/m
    wlong<-rbind(wlong,imputeId)
    wlong$w<-ifelse(apply(wlong,1,anyNA),0,wlong$w)
    if(sum(wlong$r.ptrn)!=nrow(wlong)){
      weights<-wlong$w
    }else{
      weights<-rep(1,nrow(data))
    }
    
    dt<-na.omit(wlong)
    weights<-dt$w
  }else{
    dt<-dt
    weights<-rep(1,nrow(data))
  }
  
  dat <- model.frame(formula=formula, data=dt, na.action=na.exclude)
  len<-data.frame(table(dt$id))
  nn <- dim(dat)[1]
  corlist<-c("independence", "ar1", "exchangeable", "m-dependent", "unstructured", "fixed", "userdefined")
  cor.match <- charmatch(corstr, corlist)
  
  fmly<-get(family, mode = "function", envir = parent.frame(2))
  fmly<-fmly()
  LinkFun <- fmly$linkfun
  InvLink <- fmly$linkinv
  VarFun <- fmly$variance
  InvLinkDeriv <- fmly$mu.eta
  
  modterms <- terms(formula)
  X <- model.matrix(formula,dat)
  Y <- model.response(dat)
  p <- dim(X)[2]
  W <- Diagonal(x=weights)
  sqrtW <- sqrt(W)
  K <- length(unique(dt$id))
  StdErr <- Diagonal(nn)
  dInvLinkdEta <- Diagonal(nn)
  Resid <- Diagonal(nn)
  
  
  if(is.null(init.phi)){
    init.phi<-1
  }else{
    init.phi<-init.phi
  }
  phi<-init.phi
  
  linkOfMean <- LinkFun(mean(Y))
  if(is.null(init.beta)){
    init.beta <- rep(0, dim(X)[2])
    init.beta[1] <- linkOfMean
  }else{
    init.beta<-init.beta
  }
  beta <- init.beta
  
  if(is.null(init.alpha)){
    init.alpha<-init.alpha
  }else{
    init.alpha<-init.alpha
  }
  
  stop <- F
  converged <- F
  count <- 0
  unstable <- F
  phiold <- phi
  kbeta <- beta
  alpha<-init.alpha
  R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
  betalist<-list()
  p=0
  while(!stop){
    p <- p+1
    off<-0
    eta <- as.vector(X %*% beta) + off
    
    mu <- InvLink(eta)
    diag(dInvLinkdEta)<-InvLinkDeriv(eta)
    diag(StdErr) <- sqrt(1/VarFun(mu))
    
    #R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
    #R.alpha.inv<-as.matrix(R.alpha.inv)
    UpdatePhi<-function(y,x,vfun,mu,w){
      ymu<-(as.matrix(y-mu,ncol=1,nrow=length(y),byrow=T))
      res<-vfun%*%(w%*%(ymu))
      Newphi<-sum(res*res)/(length(y)-ncol(x))
      Newphi
    }
    phi.new<-UpdatePhi(y=Y,x=X,vfun=StdErr,mu=mu,w=W)
    phi<-phi.new
    
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=1;corstr = corstr;ni=len$Freq;mv=NULL;id=id$Pig;visit=visit$Time
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=phi;corstr = corstr;ni=len$Freq;mv=NULL;id=dt$id;visit=dt$visit
    
    updateALpha<-function(y,x,vfun,mu,w,phi,corstr,ni,mv=NULL,id,visit){
      nk<-max(ni)
      Alpha<-NULL
      Resid<-vfun%*%((y-mu))
      dt2<-cbind.data.frame(Res=as.vector(Resid),id=id,visit=visit)
      Ralpha<-matrix(1,ncol=nk,nrow=nk)
      ResidMatlist<-list()
      length(ResidMatlist)<-length(ni)
      for(i in 1:length(ResidMatlist)){
        a<-rep(NA,nk)
        dt1<-dt2[dt2$id==unique(dt2$id)[1],]
        a[c(which(c(1:nk)%in%dt1$visit==T))]<-dt1$Res
        a[is.na(a)]<-0
        ResidMatlist[[i]]<-triu(a%*%t(a))
      }
      resMAtsum<-Reduce('+',ResidMatlist)
      
      if(corstr=='fixed'){
        Ralpha<-Ralpha.fixed
      }else if(corstr=="independent"){
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-0
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
        
      }else if(corstr=='unstructured'){
        Ralpha<-resMAtsum/((sum(ni)-ncol(x))*phi)
        diag(Ralpha)<-1
        #ResidNa<-bdiag(ResidMatlist)
        #ResidNa2<-band(ResidNa,k1=1,k2=dim(ResidNa)[2])
        
      }else if(corstr=='exchangeable'){
        Alpha<-(sum(resMAtsum)-sum(diag(resMAtsum)))/(phi*(sum(ni*ni)-sum(ni)-ncol(x)))
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }else if(corstr=='AR-1'){
        Alpha<-(sum(triu(resMAtsum,k=1)))/((sum(ni-1)-ncol(x))*phi)
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha^(abs(i-j))
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }
      Ralpha
    }
    ralpha<-updateALpha(y=Y,x=X,vfun=StdErr,mu=mu,w=W,phi=phi,corstr = corstr,ni=len$Freq,mv=NULL,id=dt$id,visit=dt$visit)
    ralpha<-ralpha*phi
    ralpha.list<-list()
    blockdiag<-c()
    for(i in 1:length(unique(dt$id))){
      
      dt1<-dt[dt$id==unique(dt$id)[i],]
      ralpha.list[[i]]<-ginv(as.matrix(ralpha[c(dt1$visit),c(dt1$visit)]))
      blockdiag[i]<-length(dt1$id)
    }
    R.alpha.inv<-(bdiag(ralpha.list))
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;D=dInvLinkdEta;Ralpha=R.alpha.inv;beta=beta
    updateBeta<-function(y,x,vfun,mu,w,D,Ralpha,beta){
      hess<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%D%*%w%*%x
      u<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%w%*%as.matrix(y-mu)
      Newbeta<-beta+solve(as.matrix(hess),u)
      rslt<-list()
      rslt$Newbeta<-Newbeta
      rslt$hess<-hess
      rslt
    }
    Beta<-updateBeta(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta)
    betaNew<-Beta$Newbeta
    phi <- phi.new
    R.alpha.inv<-as.matrix(R.alpha.inv)
    phiold <- phi
    beta<-betaNew
    if( max(abs((beta - kbeta)/(beta+.Machine$double.eps ))) < tol ){converged <- T; stop <- T}
    if(p >= maxit){stop <- T}
    
    betalist[[p]]<-betaNew
    betaold<-beta
  }
  eta <- as.vector(X %*% beta)
  mu <- InvLink(eta)
  diag(dInvLinkdEta)<-InvLinkDeriv(eta)
  diag(StdErr) <- sqrt(1/VarFun(mu))
  updateSandW<-function(y,x,vfun,mu,w,D,Ralpha,beta,hessmat,blockdiag){
    blockmat<-function(blen,xmat){
      index<-blen
      xmat1<-xmat
      matlist<-list()
      for(i in 1:(length(blen)-1)){
        xmat2<-xmat1[1:blen[i],1:blen[i]]
        matlist[[i]]<-xmat2
        xmat1<-xmat1[-c(1:blen[i]),-c(1:blen[i])]
      }
      matlist[[length(blen)]]<-xmat1
      bmat<-bdiag(matlist)
      bmat
      
    }
    Blockdiag<-blockmat(blen=blockdiag,xmat=as.matrix(y-mu)%*%t(as.matrix(y-mu)))
    
    sigmahat<-Blockdiag
    usand<-t(x)%*%t(D)%*%vfun%*%Ralpha%*%vfun%*%w%*%sigmahat%*%w%*%vfun%*%Ralpha%*%vfun%*%D%*%x
    hessmat<-as.matrix(hessmat)
    upSandwich<-t(solve(hessmat,usand))
    #upSandwich<-upSandwich%*%solve(hessmat)
    upSandwich<-t(solve(t(hessmat),upSandwich))
    upSandwich
  }
  betaSand<-updateSandW(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta,
                        hessmat = Beta$hess,blockdiag=blockdiag)
  reslt<-list()
  reslt$call<-call
  reslt$beta<-beta
  reslt$niter<-p
  reslt$betalist<-betalist
  reslt$Ralpha<-ralpha/phi
  reslt$weight<-W
  reslt$mu<-mu
  reslt$y<-Y
  reslt$phi<-phi
  reslt$hessian<-Beta$hess
  reslt$betaSand<-betaSand
  reslt$imputedata<-wlongMice
  reslt$model<-deparse1(formula)
  reslt$nimp<-m
  reslt$method<-"miaipw"
  class(reslt) <- "ipw"
  return(reslt)
}

MeanScore1<-function(data,formula,id,visit,family,init.beta=NULL,init.alpha=NULL,
                    init.phi=NULL,tol=0.001,weights=NULL,corstr='independent',maxit=50,m=2,pMat,method=NULL){
  call<-match.call()
  arg_checks <- as.list(match.call())[-1]
  arg_checks$fomula <-deparse(formula)
  if(is.null(data)){
    stop("data can't be NULL")
  }
  if(is.null(id)){
    stop("id can't be NULL")
  }
  if(is.null(visit)){
    stop("visit can't be NULL")
  }
  if(is.null(family)){
    stop("family can't be NULL, must be from exponential distribution")
  }
  dt<-data
  stopifnot(id%in%names(dt))
  stopifnot(visit%in%names(dt))
  modeldata<-model.frame(formula,dt)
  names(dt)[which(names(dt)==id)]<-'id'
  names(dt)[which(names(dt)==visit)]<-'visit'
  dtid<-data.frame(table(dt$id))
  dtid<-dtid[2]
  dtidvisit<-table(dt$id,dt$visit)
  #if(max(dtid)>maxvisit){
  # stop("Some id's having visits more than",maxvisit)
  #}
  uniqueVisit<-unique(dt$visit)
  for(i in 1:length(uniqueVisit)){
    dt[dt$visit==uniqueVisit[i],]$visit<-i
  }
  init.beta<-init.beta;init.alpha<-init.alpha;init.phi<-init.phi
  
  # function to create IPW
  
  #mdata<-data.frame(id=c(rep(1,4),rep(2,4),rep(3,4)),visit=rep(1:4,3),y=rnorm(12,0,1),x1=rnorm(12,2,1),x3=c(1,1,1,1,1,NA,NA,NA,NA,NA,1,1))
  #data<-mdata;id<-'id';visit<-'visit';formula<-y~x1+x3
  #data<-dt;id<-'id';visit<-'visit';formula<-C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM
  #pMat<-make.predictorMatrix(data[names(data)%in%all.vars(formula)]);m=1;method=NULL
  if(anyNA(dt)==T){
    meanlong<-function(data,id,visit,formula)
    {
      dt<-data
      mterms<-all.vars(formula)
      #names(dt)[which(names(dt)==y)]<-'y'
      names(dt)[which(names(dt)==visit)]<-'visit'
      names(dt)[which(names(dt)==id)]<-'id'
      nvisit<-length(unique(dt$visit))
      k1<-which(colnames(dt)=='visit')
      k2<-which(colnames(dt)=='id')
      dt1<-dt[names(dt)%in%c('id','visit',mterms)==T]
      
      dt<-cbind(dt,r.ptrn=as.numeric(apply(dt,1,anyNA)))
      dt$r.ptrn<-ifelse(dt$r.ptrn==0,1,0)
      dtlist<-split(dt,dt$visit)
      mprob1<-NULL
      for(i in 1:nvisit){
        dt2<-dtlist[[i]]
        xptrn<-apply(dt2,2,anyNA)
        xmodel<-mterms
        fxmodel<-xptrn[names(xptrn)%in%mterms]
        fxmodel<-fxmodel[fxmodel==F]
        dt2new<-dt2[names(dt2)%in%mterms]
        micemodel<-mice::mice(
          data=dt2new,
          m=m,
          method=method,
          predictorMatrix=pMat,
          ignore=NULL,printFlag = F
          
        )
        completeList<-complete(micemodel,1)
        #names(dt2)[names(dt2)%in%names(fxmodel)]<-names(completeList)[names(dt2)%in%names(fxmodel)]
        dt2[names(dt2)%in%mterms]<-completeList
        modeldt2<-formula(paste0('r.ptrn~',paste(names(fxmodel),collapse = '+')))
        m1<-glm(modeldt2,data=dt2,family='binomial')
        dt2<-data.frame(dt2,w=m1$fitted.values)
        for(j in 1:length(dt2$id)){
          if(dt2$r.ptrn[j]==1){
            dt2$w[j]<-1
          }else{
            dt2$w[j]<-1
          }
        }
        #dt2$w<-sapply(dt2$r.ptrn,dt2$w,1-dt$w)
        mprob1[[i]]<-dt2
      }
      reddt<-Reduce('rbind',mprob1)
      reddt<-reddt[order(reddt$id),]
      reddt
    }
    wlong<-meanlong(data=dt,id=id,visit=visit,formula=formula)
    #weights<-rep(1,nrow(data))
    wlong$w<-ifelse(apply(wlong,1,anyNA),0,wlong$w)
    if(sum(wlong$r.ptrn)!=nrow(wlong)){
      weights<-wlong$w
    }else{
      weights<-rep(1,nrow(data))
    }
    
    dt<-na.omit(wlong)
    weights<-dt$w
  }else{
    dt<-dt
    weights<-rep(1,nrow(data))
  }
  dat <- model.frame(formula=formula, data=dt, na.action=na.exclude)
  len<-data.frame(table(dt$id))
  nn <- dim(dat)[1]
  corlist<-c("independence", "ar1", "exchangeable", "m-dependent", "unstructured", "fixed", "userdefined")
  cor.match <- charmatch(corstr, corlist)
  
  fmly<-get(family, mode = "function", envir = parent.frame(2))
  fmly<-fmly()
  LinkFun <- fmly$linkfun
  InvLink <- fmly$linkinv
  VarFun <- fmly$variance
  InvLinkDeriv <- fmly$mu.eta
  
  modterms <- terms(formula)
  X <- model.matrix(formula,dat)
  Y <- model.response(dat)
  p <- dim(X)[2]
  W <- Diagonal(x=weights)
  sqrtW <- sqrt(W)
  K <- length(unique(dt$id))
  StdErr <- Diagonal(nn)
  dInvLinkdEta <- Diagonal(nn)
  Resid <- Diagonal(nn)
  
  if(is.null(init.phi)){
    init.phi<-1
  }else{
    init.phi<-init.phi
  }
  phi<-init.phi
  
  linkOfMean <- LinkFun(mean(Y))
  if(is.null(init.beta)){
    init.beta <- rep(0, dim(X)[2])
    init.beta[1] <- linkOfMean
  }else{
    init.beta<-init.beta
  }
  beta <- init.beta
  
  if(is.null(init.alpha)){
    init.alpha<-init.alpha
  }else{
    init.alpha<-init.alpha
  }
  #beta<-init.beta
  #len <- as.numeric(summary(split(Y, id, drop=T))[,1])
  #BlockDiag <- getBlockDiag(len)$BDiag
  stop <- F
  converged <- F
  count <- 0
  unstable <- F
  phiold <- phi
  beta <- init.beta
  kbeta <- beta
  alpha<-init.alpha
  R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
  betalist<-list()
  p=0
  while(p<maxit){
    p <- p+1
    off<-0
    eta <- as.vector(X %*% beta) + off
    
    mu <- InvLink(eta)
    diag(dInvLinkdEta)<-InvLinkDeriv(eta)
    diag(StdErr) <- sqrt(1/VarFun(mu))
    
    #R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
    #R.alpha.inv<-as.matrix(R.alpha.inv)
    UpdatePhi<-function(y,x,vfun,mu,w){
      ymu<-(as.matrix(y-mu,ncol=1,nrow=length(y),byrow=T))
      res<-vfun%*%(w%*%(ymu))
      Newphi<-sum(res*res)/(length(y)-ncol(x))
      Newphi
    }
    phi.new<-UpdatePhi(y=Y,x=X,vfun=StdErr,mu=mu,w=W)
    phi<-phi.new
    
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=1;corstr = corstr;ni=len$Freq;mv=NULL;id=id$Pig;visit=visit$Time
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=phi;corstr = corstr;ni=len$Freq;mv=NULL;id=dt$id;visit=dt$visit
    
    updateALpha<-function(y,x,vfun,mu,w,phi,corstr,ni,mv=NULL,id,visit){
      nk<-max(ni)
      Alpha<-NULL
      Resid<-vfun%*%((y-mu))
      dt2<-cbind.data.frame(Res=as.vector(Resid),id=id,visit=visit)
      Ralpha<-matrix(1,ncol=nk,nrow=nk)
      ResidMatlist<-list()
      length(ResidMatlist)<-length(ni)
      for(i in 1:length(ResidMatlist)){
        a<-rep(NA,nk)
        dt1<-dt2[dt2$id==unique(dt2$id)[1],]
        a[c(which(c(1:nk)%in%dt1$visit==T))]<-dt1$Res
        a[is.na(a)]<-0
        ResidMatlist[[i]]<-triu(a%*%t(a))
      }
      resMAtsum<-Reduce('+',ResidMatlist)
      
      if(corstr=='fixed'){
        Ralpha<-Ralpha.fixed
      }else if(corstr=="independent"){
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-0
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
        
      }else if(corstr=='unstructured'){
        Ralpha<-resMAtsum/((sum(ni)-ncol(x))*phi)
        diag(Ralpha)<-1
        #ResidNa<-bdiag(ResidMatlist)
        #ResidNa2<-band(ResidNa,k1=1,k2=dim(ResidNa)[2])
        
      }else if(corstr=='exchangeable'){
        Alpha<-(sum(resMAtsum)-sum(diag(resMAtsum)))/(phi*(sum(ni*ni)-sum(ni)-ncol(x)))
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }else if(corstr=='AR-1'){
        Alpha<-(sum(triu(resMAtsum,k=1)))/((sum(ni-1)-ncol(x))*phi)
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha^(abs(i-j))
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }
      Ralpha
    }
    ralpha<-updateALpha(y=Y,x=X,vfun=StdErr,mu=mu,w=W,phi=phi,corstr = corstr,ni=len$Freq,mv=NULL,id=dt$id,visit=dt$visit)
    ralpha<-ralpha*phi
    ralpha.list<-list()
    blockdiag<-c()
    for(i in 1:length(unique(dt$id))){
      
      dt1<-dt[dt$id==unique(dt$id)[i],]
      ralpha.list[[i]]<-ginv(as.matrix(ralpha[c(dt1$visit),c(dt1$visit)]))
      blockdiag[i]<-length(dt1$id)
    }
    R.alpha.inv<-(bdiag(ralpha.list))
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;D=dInvLinkdEta;Ralpha=R.alpha.inv;beta=beta
    updateBeta<-function(y,x,vfun,mu,w,D,Ralpha,beta){
      hess<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%D%*%w%*%x
      u<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%w%*%as.matrix(y-mu)
      Newbeta<-beta+solve(as.matrix(hess),u)
      rslt<-list()
      rslt$Newbeta<-Newbeta
      rslt$hess<-hess
      rslt
    }
    Beta<-updateBeta(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta)
    betaNew<-Beta$Newbeta
    phi <- phi.new
    R.alpha.inv<-as.matrix(R.alpha.inv)
    phiold <- phi
    beta<-betaNew
    if( max(abs((beta - kbeta)/(beta+.Machine$double.eps ))) < tol ){converged <- T; stop <- T}
    if(p >= maxit){stop <- T}
    
    betalist[[p]]<-betaNew
    betaold<-beta
  }
  eta <- as.vector(X %*% beta)
  mu <- InvLink(eta)
  diag(dInvLinkdEta)<-InvLinkDeriv(eta)
  diag(StdErr) <- sqrt(1/VarFun(mu))
  updateSandW<-function(y,x,vfun,mu,w,D,Ralpha,beta,hessmat,blockdiag){
    blockmat<-function(blen,xmat){
      index<-blen
      xmat1<-xmat
      matlist<-list()
      for(i in 1:(length(blen)-1)){
        xmat2<-xmat1[1:blen[i],1:blen[i]]
        matlist[[i]]<-xmat2
        xmat1<-xmat1[-c(1:blen[i]),-c(1:blen[i])]
      }
      matlist[[length(blen)]]<-xmat1
      bmat<-bdiag(matlist)
      bmat
      
    }
    Blockdiag<-blockmat(blen=blockdiag,xmat=as.matrix(y-mu)%*%t(as.matrix(y-mu)))
    
    sigmahat<-Blockdiag
    usand<-t(x)%*%t(D)%*%vfun%*%Ralpha%*%vfun%*%w%*%sigmahat%*%w%*%vfun%*%Ralpha%*%vfun%*%D%*%x
    hessmat<-as.matrix(hessmat)
    upSandwich<-t(solve(hessmat,usand))
    #upSandwich<-upSandwich%*%solve(hessmat)
    upSandwich<-t(solve(t(hessmat),upSandwich))
    upSandwich
  }
  betaSand<-updateSandW(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta,
                        hessmat = Beta$hess,blockdiag=blockdiag)
  reslt<-list()
  reslt$call<-call
  reslt$beta<-beta
  reslt$niter<-p
  reslt$betalist<-betalist
  reslt$Ralpha<-ralpha/phi
  reslt$weight<-W
  reslt$mu<-mu
  reslt$y<-Y
  reslt$phi<-phi
  reslt$hessian<-Beta$hess
  reslt$betaSand<-betaSand
  reslt$imputedata<-wlong
  reslt$model<-deparse1(formula)
  reslt$nimp<-m
  reslt$method<-"meanscore"
  class(reslt) <- "meanscore"
  return(reslt)
}


AIPW1<-function(data,formula,id,visit,family,init.beta=NULL,init.alpha=NULL,
               init.phi=NULL,tol=0.001,weights=NULL,corstr='independent',maxit=50,m=2,pMat,method=NULL){
  call<-match.call()
  arg_checks <- as.list(match.call())[-1]
  arg_checks$fomula <-deparse(formula)
  if(is.null(data)){
    stop("data can't be NULL")
  }
  if(is.null(id)){
    stop("id can't be NULL")
  }
  if(is.null(visit)){
    stop("visit can't be NULL")
  }
  if(is.null(family)){
    stop("family can't be NULL, must be from exponential distribution")
  }
  dt<-data
  stopifnot(id%in%names(dt))
  stopifnot(visit%in%names(dt))
  
  modeldata<-model.frame(formula,dt)
  names(dt)[which(names(dt)==id)]<-'id'
  names(dt)[which(names(dt)==visit)]<-'visit'
  dtid<-data.frame(table(dt$id))[2]
  dtidvisit<-table(dt$id,dt$visit)
  #if(max(dtid)>maxvisit){
  #  stop("Some id's having visits more than",maxvisit)
  # }
  uniqueVisit<-unique(dt$visit)
  for(i in 1:length(uniqueVisit)){
    dt[dt$visit==uniqueVisit[i],]$visit<-i
  }
  init.beta<-init.beta;init.alpha<-init.alpha;init.phi<-init.phi
  #maxvisit<-maxvisit
  # function to create IPW
  
  #mdata<-data.frame(id=c(rep(1,4),rep(2,4),rep(3,4)),visit=rep(1:4,3),y=rnorm(12,0,1),x1=rnorm(12,2,1),x3=c(1,1,1,1,1,NA,NA,NA,NA,NA,1,1))
  #data<-mdata;id<-'id';visit<-'visit';formula<-y~x1+x3
  #data<-dt;id<-'id';visit<-'visit';formula<-C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM
  #pMat<-make.predictorMatrix(data[names(data)%in%all.vars(formula)]);m=1;method=NULL
  if(anyNA(dt)==T){
    aipwlong<-function(data,id,visit,formula)
    {
      dt<-data
      mterms<-all.vars(formula)
      #names(dt)[which(names(dt)==y)]<-'y'
      names(dt)[which(names(dt)==visit)]<-'visit'
      names(dt)[which(names(dt)==id)]<-'id'
      nvisit<-length(unique(dt$visit))
      k1<-which(colnames(dt)=='visit')
      k2<-which(colnames(dt)=='id')
      dt1<-dt[names(dt)%in%c('id','visit',mterms)==T]
      
      dt<-cbind(dt,r.ptrn=as.numeric(apply(dt,1,anyNA)))
      dt$r.ptrn<-ifelse(dt$r.ptrn==0,1,0)
      dtlist<-split(dt,dt$visit)
      mprob1<-NULL
      for(i in 1:nvisit){
        dt2<-dtlist[[i]]
        xptrn<-apply(dt2,2,anyNA)
        xmodel<-mterms
        fxmodel<-xptrn[names(xptrn)%in%mterms]
        fxmodel<-fxmodel[fxmodel==F]
        dt2new<-dt2[names(dt2)%in%mterms]
        micemodel<-mice::mice(
          data=dt2new,
          m=m,
          method=method,
          predictorMatrix=pMat,
          ignore=NULL,printFlag = F
          
        )
        completeList<-complete(micemodel,1)
        #names(dt2)[names(dt2)%in%names(fxmodel)]<-names(completeList)[names(dt2)%in%names(fxmodel)]
        dt2[names(dt2)%in%mterms]<-completeList
        modeldt2<-formula(paste0('r.ptrn~',paste(names(fxmodel),collapse = '+')))
        m1<-glm(modeldt2,data=dt2,family='binomial')
        dt2<-data.frame(dt2,w=m1$fitted.values)
        for(j in 1:length(dt2$id)){
          if(dt2$r.ptrn[j]==1){
            dt2$w[j]<-1/dt2$w[j]
          }else{
            dt2$w[j]<-1/(1-dt2$w[j])
          }
        }
        #dt2$w<-sapply(dt2$r.ptrn,dt2$w,1-dt$w)
        mprob1[[i]]<-dt2
      }
      reddt<-Reduce('rbind',mprob1)
      reddt<-reddt[order(reddt$id),]
      reddt
    }
    wlong<-aipwlong(data=dt,id=id,visit=visit,formula=formula)
    #weights<-rep(1,nrow(data))
    wlong$w<-ifelse(apply(wlong,1,anyNA),0,wlong$w)
    if(sum(wlong$r.ptrn)!=nrow(wlong)){
      weights<-wlong$w
    }else{
      weights<-rep(1,nrow(data))
    }
    dt<-na.omit(wlong)
    weights<-dt$w
  }else{
    dt<-dt
    weights<-rep(1,nrow(data))
  }
  
  
  dat <- model.frame(formula=formula, data=dt, na.action=na.exclude)
  len<-data.frame(table(dt$id))
  nn <- dim(dat)[1]
  corlist<-c("independence", "ar1", "exchangeable", "unstructured", "fixed", "userdefined")
  cor.match <- charmatch(corstr, corlist)
  
  
  
  fmly<-get(family, mode = "function", envir = parent.frame(2))
  fmly<-fmly()
  LinkFun <- fmly$linkfun
  InvLink <- fmly$linkinv
  VarFun <- fmly$variance
  InvLinkDeriv <- fmly$mu.eta
  #dt<-na.omit(wlong)
  #weights<-dt$w
  
  modterms <- terms(formula)
  X <- model.matrix(formula,dat)
  Y <- model.response(dat)
  p <- dim(X)[2]
  W <- Diagonal(x=weights)
  sqrtW <- sqrt(W)
  K <- length(unique(dt$id))
  StdErr <- Diagonal(nn)
  dInvLinkdEta <- Diagonal(nn)
  Resid <- Diagonal(nn)
  
  
  if(is.null(init.phi)){
    init.phi<-1
  }else{
    init.phi<-init.phi
  }
  phi<-init.phi
  
  linkOfMean <- LinkFun(mean(Y))
  if(is.null(init.beta)){
    init.beta <- rep(0, dim(X)[2])
    init.beta[1] <- linkOfMean
  }else{
    init.beta<-init.beta
  }
  beta <- init.beta
  
  if(is.null(init.alpha)){
    init.alpha<-init.alpha
  }else{
    init.alpha<-init.alpha
  }
  #beta<-init.beta
  
  #len <- as.numeric(summary(split(Y, id, drop=T))[,1])
  #BlockDiag <- getBlockDiag(len)$BDiag
  stop <- F
  converged <- F
  count <- 0
  unstable <- F
  phiold <- phi
  kbeta <- beta
  alpha<-init.alpha
  R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
  betalist<-list()
  p=0
  while(!stop){
    p <- p+1
    off<-0
    eta <- as.vector(X %*% beta) + off
    
    mu <- InvLink(eta)
    diag(dInvLinkdEta)<-InvLinkDeriv(eta)
    diag(StdErr) <- sqrt(1/VarFun(mu))
    
    #R.alpha.inv <-  Diagonal(x = rep.int(1/phi, nn))
    #R.alpha.inv<-as.matrix(R.alpha.inv)
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W
    UpdatePhi<-function(y,x,vfun,mu,w){
      ymu<-(as.matrix(y-mu,ncol=1,nrow=length(y),byrow=T))
      res<-vfun%*%(w%*%(ymu))
      Newphi<-sum(res*res)/(length(y)-ncol(x))
      Newphi
    }
    phi.new<-UpdatePhi(y=Y,x=X,vfun=StdErr,mu=mu,w=W)
    phi<-phi.new
    
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=1;corstr = corstr;ni=len$Freq;mv=NULL;id=id$Pig;visit=visit$Time
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;phi=phi;corstr = corstr;ni=len$Freq;mv=NULL;id=dt$id;visit=dt$visit
    
    updateALpha<-function(y,x,vfun,mu,w,phi,corstr,ni,mv=NULL,id,visit){
      nk<-max(ni)
      Alpha<-NULL
      Resid<-vfun%*%((y-mu))
      dt2<-cbind.data.frame(Res=as.vector(Resid),id=id,visit=visit)
      Ralpha<-matrix(1,ncol=nk,nrow=nk)
      ResidMatlist<-list()
      length(ResidMatlist)<-length(ni)
      for(i in 1:length(ResidMatlist)){
        a<-rep(NA,nk)
        dt1<-dt2[dt2$id==unique(dt2$id)[1],]
        a[c(which(c(1:nk)%in%dt1$visit==T))]<-dt1$Res
        a[is.na(a)]<-0
        ResidMatlist[[i]]<-triu(a%*%t(a))
      }
      resMAtsum<-Reduce('+',ResidMatlist)
      
      if(corstr=='fixed'){
        Ralpha<-Ralpha.fixed
      }else if(corstr=="independent"){
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-0
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
        
      }else if(corstr=='unstructured'){
        Ralpha<-resMAtsum/((sum(ni)-ncol(x))*phi)
        diag(Ralpha)<-1
        #ResidNa<-bdiag(ResidMatlist)
        #ResidNa2<-band(ResidNa,k1=1,k2=dim(ResidNa)[2])
        
      }else if(corstr=='exchangeable'){
        Alpha<-(sum(resMAtsum)-sum(diag(resMAtsum)))/(phi*(sum(ni*ni)-sum(ni)-ncol(x)))
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }else if(corstr=='AR-1'){
        Alpha<-(sum(triu(resMAtsum,k=1)))/((sum(ni-1)-ncol(x))*phi)
        for(i in 1:nk){
          for(j in 1:nk){
            if(i!=j){
              Ralpha[i,j]<-Alpha^(abs(i-j))
            }else{
              Ralpha[i,j]<-1
            }
          }
        }
      }
      Ralpha
    }
    ralpha<-updateALpha(y=Y,x=X,vfun=StdErr,mu=mu,w=W,phi=phi,corstr = corstr,ni=len$Freq,mv=NULL,id=dt$id,visit=dt$visit)
    ralpha<-ralpha*phi
    ralpha.list<-list()
    blockdiag<-c()
    for(i in 1:length(unique(dt$id))){
      
      dt1<-dt[dt$id==unique(dt$id)[i],]
      ralpha.list[[i]]<-ginv(as.matrix(ralpha[c(dt1$visit),c(dt1$visit)]))
      blockdiag[i]<-length(dt1$id)
    }
    R.alpha.inv<-(bdiag(ralpha.list))
    #y=Y;x=X;vfun=StdErr;mu=mu;w=W;D=dInvLinkdEta;Ralpha=R.alpha.inv;beta=beta
    updateBeta<-function(y,x,vfun,mu,w,D,Ralpha,beta){
      hess<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%D%*%w%*%x
      u<-t(D%*%x)%*%vfun%*%(Ralpha)%*%vfun%*%w%*%as.matrix(y-mu)
      Newbeta<-beta+solve(as.matrix(hess),u)
      rslt<-list()
      rslt$Newbeta<-Newbeta
      rslt$hess<-hess
      rslt
    }
    Beta<-updateBeta(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta)
    betaNew<-Beta$Newbeta
    phi <- phi.new
    R.alpha.inv<-as.matrix(R.alpha.inv)
    phiold <- phi
    beta<-betaNew
    if( max(abs((beta - kbeta)/(beta+.Machine$double.eps ))) < tol ){converged <- T; stop <- T}
    if(p >= maxit){stop <- T}
    
    betalist[[p]]<-betaNew
    betaold<-beta
  }
  eta <- as.vector(X %*% beta)
  mu <- InvLink(eta)
  diag(dInvLinkdEta)<-InvLinkDeriv(eta)
  diag(StdErr) <- sqrt(1/VarFun(mu))
  updateSandW<-function(y,x,vfun,mu,w,D,Ralpha,beta,hessmat,blockdiag){
    blockmat<-function(blen,xmat){
      index<-blen
      xmat1<-xmat
      matlist<-list()
      for(i in 1:(length(blen)-1)){
        xmat2<-xmat1[1:blen[i],1:blen[i]]
        matlist[[i]]<-xmat2
        xmat1<-xmat1[-c(1:blen[i]),-c(1:blen[i])]
      }
      matlist[[length(blen)]]<-xmat1
      bmat<-bdiag(matlist)
      bmat
      
    }
    Blockdiag<-blockmat(blen=blockdiag,xmat=as.matrix(y-mu)%*%t(as.matrix(y-mu)))
    
    sigmahat<-Blockdiag
    usand<-t(x)%*%t(D)%*%vfun%*%Ralpha%*%vfun%*%w%*%sigmahat%*%w%*%vfun%*%Ralpha%*%vfun%*%D%*%x
    hessmat<-as.matrix(hessmat)
    upSandwich<-t(solve(hessmat,usand))
    #upSandwich<-upSandwich%*%solve(hessmat)
    upSandwich<-t(solve(t(hessmat),upSandwich))
    upSandwich
  }
  betaSand<-updateSandW(y=Y,x=X,vfun=StdErr,mu=mu,w=W,D=dInvLinkdEta,Ralpha=R.alpha.inv,beta=beta,
                        hessmat = Beta$hess,blockdiag=blockdiag)
  reslt<-list()
  reslt$call<-call
  reslt$beta<-beta
  reslt$niter<-p
  reslt$betalist<-betalist
  reslt$Ralpha<-ralpha/phi
  reslt$weight<-W
  reslt$mu<-mu
  reslt$y<-Y
  reslt$phi<-phi
  reslt$hessian<-Beta$hess
  reslt$betaSand<-betaSand
  reslt$imputedata<-wlong
  reslt$model<-deparse1(formula)
  reslt$nimp<-m
  reslt$method<-'aipw'
  class(reslt) <- "ipw"
  return(reslt)
}


```


Introduction
=====================================  
  
  Column {data-width=1000}
-------------------------------------
  
```{r}
shinyApp(
  ui_page1 <- fluidPage(
    titlePanel("MIIPW: An R package for longitudinal data model in the presence of incmplete observations"),
    sidebarLayout(
      sidebarPanel(
        h3("MIIPW"),
        h5("Developed by :"),
        h6("Atanu Bhattacharjee"),
        h6("Bhrigu Kumar Rajbongshi"),
        h6("Gajendra K Vishwakarma"),
        p('Download MIIPW package from'),
        a("https://cran.r-project.org/web/packages/MIIPW/index.html",
          href = "https://cran.r-project.org/web/packages/MIIPW/index.html")
      ),
      mainPanel(
        p("MIIPW R package contains functions for data analysis of Repeated measurement using GEE. Data may contain missing value in response and covariates. For parameter estimation through Fisher Scoring algorithm, Mean Score and Inverse Probability Weighted method combining with Multiple Imputation are used when there is missing value in covariates/response. Reference for mean score method, inverse probability weighted method is Wang et al(2007)."),
        p("A short glimpse of the default dataset (srdata1 available in MIIPW package) we have used here is "),
         verbatimTextOutput('exampledatalong'),
        p("So there could be verious types of situation for example the subset of data for id=15 is as follows :"), 
        verbatimTextOutput('exampledatalong1'),
        p("To explore more about this we can use a visualiztion plot using naniar package"),
        plotOutput("missplot")
        
     
        
      )
    )
  ),
  server_page1 <- function(input, output, session) {
    output$exampledatalong <- renderPrint({
       #cat('First 10 rows of default Longitudinal data')
      srdata1[srdata1$ID<=3,]
    })
    output$exampledatalong1<-renderPrint({
      srdata1[srdata1$ID==15,]
    })
    
    output$missplot<-renderPlot({
      naniar::vis_miss(srdata1[,-c(1:2)])
    })
    
  },
  options = list(height=1000,width="100%")
)
```

sipw
=====================================  
  
  Column {data-width=1000}
-------------------------------------
  
```{r}
shinyApp(
  ui_page5 <-fluidPage(
  titlePanel("SIPW"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page5", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default" = "default")),
      conditionalPanel(
        condition = "input.data_option_page5== 'default'",
        selectInput("pid_page5", "ID", choices=unique(srdata1$ID),selectize = FALSE,size=5)
      ),
      conditionalPanel(
        condition = "input.data_option_page5 == 'upload'",
        fileInput("lfile_page5", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page5")
      ),
      selectInput("idvar_page5", "ID variable", choices =NULL),
      selectInput("visit_page5","Visit time",choices=NULL),
      selectInput("timevar_page5", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page5", "Longitudinal data analysis model", value = "C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM"),
      selectInput("corstr_page5","Select correlation structure", choices=c("independence","exchangeable","AR-1","unstructured")),
      selectInput("family_page5","Family to which the distribution belongs",choices=c('gaussian')),
      #numericInput("nimp_page5", "Number of imputation", value = 1),
      numericInput('by_page5',"Interval length for prediction",value=10),
      numericInput("maxit_page5","Max number of iteration",value=10),
      actionButton("submit_page5", "Submit")
    ),
    mainPanel(
      p('SIPW(): a function specifically developed(If your dataset has missing value) for GEE model for longitudinal data. The model parameters are estimated using Simple Inverse Probability Weighted estimating equation. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/MIIPW/index.html")),
      textOutput('selected_var_page5'),
      verbatimTextOutput('summarymodel_page5'),
       textOutput('selectedID_page5'),
      plotOutput('predplot_page5')
    )
  )
),
  server_page5 <- function(input, output, session) {
  defaultlongdata_page5 <- reactive({
    if (input$data_option_page5 == 'upload') {
      req(input$lfile_page5)
      defaultlongdata_page5 <- read.csv(input$lfile_page5$datapath)
    } else {
      defaultlongdata_page5 <- srdata1
    }
    return(defaultlongdata_page5)
  })
  
  observeEvent(defaultlongdata_page5(), {
    updateSelectInput(session, "idvar_page5", choices = names(defaultlongdata_page5()))
  })
  defaultlongdataid_page5 <- reactive({
    if (input$data_option_page5 == 'upload') {
      req(input$lfile_page5)
      req(input$idvar_page5)
      defaultlongdataid_page5 <- read.csv(input$lfile_page5$datapath)
      defaultlongdataid_page5 <-defaultlongdataid_page5[!duplicated(defaultlongdataid_page5[[input$idvar_page5]]),]
    } else {
      defaultlongdataid_page5 <- srdata1
      defaultlongdataid_page5 <-defaultlongdataid_page5[!duplicated(defaultlongdataid_page5[[input$idvar_page5]]),]
    }
    return(defaultlongdataid_page5)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page5 <- renderUI({
    req(input$idvar_page5)
    tagList(
      selectInput("pid_page55", "Subject ID", choices=defaultlongdataid_page5()[[input$idvar_page5]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page5(), {
    updateSelectInput(session, "timevar_page5", choices = names(defaultlongdata_page5()))
    updateSelectInput(session, "visit_page5", choices = names(defaultlongdata_page5()))
  })
  output$selected_var_page5 <- reactive({
    
    if (input$data_option_page5 == "default") {
      req(input$pid_page5)
      paste("You have selected subject ID", input$pid_page5)
    } else {
      req(input$pid_page55)
      paste("Uploaded data selected with subject ID",input$pid_page55)
    }
  })
  
  output$selectedID_page5 <- reactive({
    if (input$data_option_page5 == "default") {
      req(input$pid_page5)
      paste('Prediction of marginal effect using model fitted through SIPW() for the selected subject ID: ',input$pid_page5)
    } else {
      req(input$pid_page55)
      paste('Prediction of marginal effect using SIPW() for the selected subject ID: ',input$pid_page55)
    }
  })
  rv_page5<-reactiveValues(model_page5=NULL)
  
  
  observeEvent(input$submit_page5,{
    # Load default data
    output$summarymodel_page5 <- renderPrint({
      req(input$analysismodel_page5)
      req(input$idvar_page5)
      req(input$visit_page5)
      req(input$timevar_page5)
      #req(input$nimp_page5)
      req(input$corstr_page5)
      req(input$maxit_page5)
      req(input$family_page5)
      fitmodel_page55 <- SIPW1(data= defaultlongdata_page5() ,
                              formula= as.formula(input$analysismodel_page5),    
                              id= input$idvar_page5,
                              visit=input$visit_page5,
                              family=input$family_page5,
                              corstr=input$corstr_page5,
                              maxit=input$maxit_page5
                              )
      rv_page5$model_page5<-fitmodel_page55
      list(beta=fitmodel_page55$beta,var.beta=fitmodel_page55$betaSand)
    })
    
  })
  
   observeEvent(input$submit_page5,{
     # Load default data
     output$predplot_page5 <- renderPlot({
       req(input$data_option_page5)
       if(input$data_option_page5 == "default"){
         req(input$analysismodel_page5)
         req(input$idvar_page5)
         req(input$visit_page5)
         req(input$pid_page5)
         req(input$timevar_page5)
         #req(input$nimp_page5)
         req(input$corstr_page5)
         req(input$maxit_page5)
         req(input$family_page5)
         req(input$by_page5)
         
         pred_sipw_page5<-predGEE(data=defaultlongdata_page5(),idnumber=input$pid_page5,idvar=input$idvar_page5,
                                       fittedObject = rv_page5$model_page5,time=input$timevar_page5,by=input$by_page5)
         predplotGEE(pred_sipw_page5,scatter=F)
         
       }else{
         req(input$analysismodel_page5)
         req(input$idvar_page5)
         req(input$visit_page5)
         req(input$pid_page55)
         req(input$timevar_page5)
         #req(input$nimp_page5)
         req(input$corstr_page5)
         req(input$maxit_page5)
         req(input$family_page5)
         req(input$by_page5)
         
         pred_sipw_page5<-predGEE(data=defaultlongdata_page5(),idnumber=input$pid_page55,idvar=input$idvar_page5,
                                       fittedObject = rv_page5$model_page5,time=input$timevar_page5,by=input$by_page5)
         predplotGEE(pred_sipw_page5,scatter=F)
       }
     })
   })
  
},
  options = list(height=1000,width="100%")
)
```


miSIPW
=====================================  
  
  Column {data-width=1000}
-------------------------------------
  
```{r}
shinyApp(
  ui_page6 <-fluidPage(
  
  titlePanel("miSIPW"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page6", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default" = "default")),
      conditionalPanel(
        condition = "input.data_option_page6== 'default'",
        selectInput("pid_page6", "ID", choices=unique(srdata1$ID),selectize = FALSE,size=5)
      ),
      conditionalPanel(
        condition = "input.data_option_page6 == 'upload'",
        fileInput("lfile_page6", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page6")
      ),
      selectInput("idvar_page6", "ID variable", choices =NULL),
      selectInput("visit_page6","Visit time",choices=NULL),
      selectInput("timevar_page6", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page6", "Longitudinal data analysis model", value = "C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM"),
      selectInput("corstr_page6","Select correlation structure", choices=c("independence","exchangeable","AR-1","unstructured")),
      selectInput("family_page6","Family to which the distribution belongs",choices=c('gaussian')),
      #numericInput("nimp_page6", "Number of imputation", value = 1),
      numericInput('by_page6',"Interval length for prediction",value=10),
      numericInput("maxit_page6","Max number of iteration",value=10),
      actionButton("submit_page6", "Submit")
    ),
    mainPanel(
      p('miSIPW(): a function specifically developed(If your dataset has missing value) for GEE model for longitudinal data. The model parameters are estimated using Multiply Imputed Simple Inverse Probability Weighted estimating equation. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/MIIPW/index.html")),
      textOutput('selected_var_page6'),
      verbatimTextOutput('summarymodel_page6'),
      textOutput('selectedID_page6'),
      plotOutput('predplot_page6')
    )
  )
)
,
  server_page6 <- function(input, output, session) {
  defaultlongdata_page6 <- reactive({
    if (input$data_option_page6 == 'upload') {
      req(input$lfile_page6)
      defaultlongdata_page6 <- read.csv(input$lfile_page6$datapath)
    } else {
      defaultlongdata_page6 <- srdata1
    }
    return(defaultlongdata_page6)
  })
  
  observeEvent(defaultlongdata_page6(), {
    updateSelectInput(session, "idvar_page6", choices = names(defaultlongdata_page6()))
  })
  defaultlongdataid_page6 <- reactive({
    if (input$data_option_page6 == 'upload') {
      req(input$lfile_page6)
      req(input$idvar_page6)
      defaultlongdataid_page6 <- read.csv(input$lfile_page6$datapath)
      defaultlongdataid_page6 <-defaultlongdataid_page6[!duplicated(defaultlongdataid_page6[[input$idvar_page6]]),]
    } else {
      defaultlongdataid_page6 <- srdata1
      defaultlongdataid_page6 <-defaultlongdataid_page6[!duplicated(defaultlongdataid_page6[[input$idvar_page6]]),]
    }
    return(defaultlongdataid_page6)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page6 <- renderUI({
    req(input$idvar_page6)
    tagList(
      selectInput("pid_page66", "Subject ID", choices=defaultlongdataid_page6()[[input$idvar_page6]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page6(), {
    updateSelectInput(session, "timevar_page6", choices = names(defaultlongdata_page6()))
    updateSelectInput(session, "visit_page6", choices = names(defaultlongdata_page6()))
  })
  output$selected_var_page6 <- reactive({
    
    if (input$data_option_page6 == "default") {
      req(input$pid_page6)
      paste("You have selected subject ID", input$pid_page6)
    } else {
      req(input$pid_page66)
      paste("Uploaded data selected with subject ID",input$pid_page66)
    }
  })
  
  output$selectedID_page6 <- reactive({
    if (input$data_option_page6 == "default") {
      req(input$pid_page6)
      paste('Prediction of marginal effect using model fitted through miSIPW() for the selected subject ID: ',input$pid_page6)
    } else {
      req(input$pid_page66)
      paste('Prediction of marginal effect using miSIPW() for the selected subject ID: ',input$pid_page66)
    }
  })
  rv_page6<-reactiveValues(model_page6=NULL)
  
  
  observeEvent(input$submit_page6,{
    # Load default data
    output$summarymodel_page6 <- renderPrint({
      req(input$analysismodel_page6)
      req(input$idvar_page6)
      req(input$visit_page6)
      req(input$timevar_page6)
      #req(input$nimp_page6)
      req(input$corstr_page6)
      req(input$maxit_page6)
      req(input$family_page6)
      
      pMat_page6<-mice::make.predictorMatrix(defaultlongdata_page6()[names(defaultlongdata_page6())%in%all.vars(as.formula(input$analysismodel_page6))])
      
      fitmodel_page66 <- miSIPW1(data= defaultlongdata_page6() ,
                               formula= as.formula(input$analysismodel_page6),    
                               id= input$idvar_page6,
                               visit=input$visit_page6,
                               family=input$family_page6,
                               corstr=input$corstr_page6,
                               maxit=input$maxit_page6,
                               pMat=pMat_page6
                               )
      rv_page6$model_page6<-fitmodel_page66
      list(beta=fitmodel_page66$beta,var.beta=fitmodel_page66$betaSand)
    })
    
  })
  
  observeEvent(input$submit_page6,{
    # Load default data
    output$predplot_page6 <- renderPlot({
      req(input$data_option_page6)
      if(input$data_option_page6 == "default"){
        req(input$analysismodel_page6)
        req(input$idvar_page6)
        req(input$visit_page6)
        req(input$pid_page6)
        req(input$timevar_page6)
        #req(input$nimp_page6)
        req(input$corstr_page6)
        req(input$maxit_page6)
        req(input$family_page6)
        req(input$by_page6)
        
        pred_sipw_page6<-predGEE(data=defaultlongdata_page6(),idnumber=input$pid_page6,idvar=input$idvar_page6,
                                      fittedObject = rv_page6$model_page6,time=input$timevar_page6,by=input$by_page6)
        predplotGEE(pred_sipw_page6,scatter=F)
        
      }else{
        req(input$analysismodel_page6)
        req(input$idvar_page6)
        req(input$visit_page6)
        req(input$pid_page66)
        req(input$timevar_page6)
        #req(input$nimp_page6)
        req(input$corstr_page6)
        req(input$maxit_page6)
        req(input$family_page6)
        req(input$by_page6)
        
        pred_sipw_page6<-predGEE(data=defaultlongdata_page6(),idnumber=input$pid_page66,idvar=input$idvar_page6,
                                      fittedObject = rv_page6$model_page6,time=input$timevar_page6,by=input$by_page6)
        predplotGEE(pred_sipw_page6,scatter=F)
      }
    })
  })
  
},
  options = list(height=1000,width="100%")
)
```


AIPW
=====================================  
  
  Column {data-width=1000}
-------------------------------------
  
```{r}
shinyApp(
  ui_page7 <-fluidPage(
  
  titlePanel("AIPW"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page7", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default" = "default")),
      conditionalPanel(
        condition = "input.data_option_page7== 'default'",
        selectInput("pid_page7", "ID", choices=unique(srdata1$ID),selectize = FALSE,size=5)
      ),
      conditionalPanel(
        condition = "input.data_option_page7 == 'upload'",
        fileInput("lfile_page7", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page7")
      ),
      selectInput("idvar_page7", "ID variable", choices =NULL),
      selectInput("visit_page7","Visit time",choices=NULL),
      selectInput("timevar_page7", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page7", "Longitudinal data analysis model", value = "C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM"),
      selectInput("corstr_page7","Select correlation structure", choices=c("independence","exchangeable","AR-1","unstructured")),
      selectInput("family_page7","Family to which the distribution belongs",choices=c('gaussian')),
      #numericInput("nimp_page7", "Number of imputation", value = 1),
      numericInput('by_page7',"Interval length for prediction",value=10),
      numericInput("maxit_page7","Max number of iteration",value=10),
      actionButton("submit_page7", "Submit")
    ),
    mainPanel(
      p('AIPW(): a function specifically developed(If your dataset has missing value) for GEE model for longitudinal data. The model parameters are estimated using Augmented Inverse Probability Weighted estimating equation. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/MIIPW/index.html")),
      textOutput('selected_var_page7'),
      verbatimTextOutput('summarymodel_page7'),
      textOutput('selectedID_page7'),
      plotOutput('predplot_page7')
    )
  )
)
,
 server_page7 <- function(input, output, session) {
  defaultlongdata_page7 <- reactive({
    if (input$data_option_page7 == 'upload') {
      req(input$lfile_page7)
      defaultlongdata_page7 <- read.csv(input$lfile_page7$datapath)
    } else {
      defaultlongdata_page7 <- srdata1
    }
    return(defaultlongdata_page7)
  })
  
  observeEvent(defaultlongdata_page7(), {
    updateSelectInput(session, "idvar_page7", choices = names(defaultlongdata_page7()))
  })
  defaultlongdataid_page7 <- reactive({
    if (input$data_option_page7 == 'upload') {
      req(input$lfile_page7)
      req(input$idvar_page7)
      defaultlongdataid_page7 <- read.csv(input$lfile_page7$datapath)
      defaultlongdataid_page7 <-defaultlongdataid_page7[!duplicated(defaultlongdataid_page7[[input$idvar_page7]]),]
    } else {
      defaultlongdataid_page7 <- srdata1
      defaultlongdataid_page7 <-defaultlongdataid_page7[!duplicated(defaultlongdataid_page7[[input$idvar_page7]]),]
    }
    return(defaultlongdataid_page7)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page7 <- renderUI({
    req(input$idvar_page7)
    tagList(
      selectInput("pid_page77", "Subject ID", choices=defaultlongdataid_page7()[[input$idvar_page7]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page7(), {
    updateSelectInput(session, "timevar_page7", choices = names(defaultlongdata_page7()))
    updateSelectInput(session, "visit_page7", choices = names(defaultlongdata_page7()))
  })
  output$selected_var_page7 <- reactive({
    
    if (input$data_option_page7 == "default") {
      req(input$pid_page7)
      paste("You have selected subject ID", input$pid_page7)
    } else {
      req(input$pid_page77)
      paste("Uploaded data selected with subject ID",input$pid_page77)
    }
  })
  
  output$selectedID_page7 <- reactive({
    if (input$data_option_page7 == "default") {
      req(input$pid_page7)
      paste('Prediction of marginal effect using model fitted through AIPW() for the selected subject ID: ',input$pid_page7)
    } else {
      req(input$pid_page77)
      paste('Prediction of marginal effect using AIPW() for the selected subject ID: ',input$pid_page77)
    }
  })
  rv_page7<-reactiveValues(model_page7=NULL)
  
  
  observeEvent(input$submit_page7,{
    # Load default data
    output$summarymodel_page7 <- renderPrint({
      req(input$analysismodel_page7)
      req(input$idvar_page7)
      req(input$visit_page7)
      req(input$timevar_page7)
      #req(input$nimp_page7)
      req(input$corstr_page7)
      req(input$maxit_page7)
      req(input$family_page7)
      
      pMat_page7<-mice::make.predictorMatrix(defaultlongdata_page7()[names(defaultlongdata_page7())%in%all.vars(as.formula(input$analysismodel_page7))])
      
      fitmodel_page77 <- AIPW1(data= defaultlongdata_page7() ,
                                 formula= as.formula(input$analysismodel_page7),    
                                 id= input$idvar_page7,
                                 visit=input$visit_page7,
                                 family=input$family_page7,
                                 corstr=input$corstr_page7,
                                 maxit=input$maxit_page7,
                                 pMat=pMat_page7
      )
      rv_page7$model_page7<-fitmodel_page77
      list(beta=fitmodel_page77$beta,var.beta=fitmodel_page77$betaSand)
    })
    
  })
  
  observeEvent(input$submit_page7,{
    # Load default data
    output$predplot_page7 <- renderPlot({
      req(input$data_option_page7)
      if(input$data_option_page7 == "default"){
        req(input$analysismodel_page7)
        req(input$idvar_page7)
        req(input$visit_page7)
        req(input$pid_page7)
        req(input$timevar_page7)
        #req(input$nimp_page7)
        req(input$corstr_page7)
        req(input$maxit_page7)
        req(input$family_page7)
        req(input$by_page7)
        
        pred_sipw_page7<-predGEE(data=defaultlongdata_page7(),idnumber=input$pid_page7,idvar=input$idvar_page7,
                                      fittedObject = rv_page7$model_page7,time=input$timevar_page7,by=input$by_page7)
        predplotGEE(pred_sipw_page7,scatter=F)
        
      }else{
        req(input$analysismodel_page7)
        req(input$idvar_page7)
        req(input$visit_page7)
        req(input$pid_page77)
        req(input$timevar_page7)
        #req(input$nimp_page7)
        req(input$corstr_page7)
        req(input$maxit_page7)
        req(input$family_page7)
        req(input$by_page7)
        
        pred_sipw_page7<-predGEE(data=defaultlongdata_page7(),idnumber=input$pid_page77,idvar=input$idvar_page7,
                                      fittedObject = rv_page7$model_page7,time=input$timevar_page7,by=input$by_page7)
        predplotGEE(pred_sipw_page7,scatter=F)
      }
    })
  })
  
},
  options = list(height=1000,width="100%")
)
```



miAIPW
=====================================  
  
  Column {data-width=1000}
-------------------------------------
  
```{r}
shinyApp(
  ui_page8 <-fluidPage(
  
  titlePanel("miAIPW"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page8", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default" = "default")),
      conditionalPanel(
        condition = "input.data_option_page8== 'default'",
        selectInput("pid_page8", "ID", choices=unique(srdata1$ID),selectize = FALSE,size=5)
      ),
      conditionalPanel(
        condition = "input.data_option_page8 == 'upload'",
        fileInput("lfile_page8", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page8")
      ),
      selectInput("idvar_page8", "ID variable", choices =NULL),
      selectInput("visit_page8","Visit time",choices=NULL),
      selectInput("timevar_page8", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page8", "Longitudinal data analysis model", value = "C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM"),
      selectInput("corstr_page8","Select correlation structure", choices=c("independence","exchangeable","AR-1","unstructured")),
      selectInput("family_page8","Family to which the distribution belongs",choices=c('gaussian')),
      #numericInput("nimp_page8", "Number of imputation", value = 1),
      numericInput('by_page8',"Interval length for prediction",value=10),
      numericInput("maxit_page8","Max number of iteration",value=10),
      actionButton("submit_page8", "Submit")
    ),
    mainPanel(
      p('miAIPW(): a function specifically developed(If your dataset has missing value) for GEE model for longitudinal data. The model parameters are estimated using Multiply Augmented Inverse Probability Weighted estimating equation. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/MIIPW/index.html")),
      textOutput('selected_var_page8'),
      verbatimTextOutput('summarymodel_page8'),
      textOutput('selectedID_page8'),
      plotOutput('predplot_page8')
    )
  )
)
,
 server_page8 <- function(input, output, session) {
  defaultlongdata_page8 <- reactive({
    if (input$data_option_page8 == 'upload') {
      req(input$lfile_page8)
      defaultlongdata_page8 <- read.csv(input$lfile_page8$datapath)
    } else {
      defaultlongdata_page8 <- srdata1
    }
    return(defaultlongdata_page8)
  })
  
  observeEvent(defaultlongdata_page8(), {
    updateSelectInput(session, "idvar_page8", choices = names(defaultlongdata_page8()))
  })
  defaultlongdataid_page8 <- reactive({
    if (input$data_option_page8 == 'upload') {
      req(input$lfile_page8)
      req(input$idvar_page8)
      defaultlongdataid_page8 <- read.csv(input$lfile_page8$datapath)
      defaultlongdataid_page8 <-defaultlongdataid_page8[!duplicated(defaultlongdataid_page8[[input$idvar_page8]]),]
    } else {
      defaultlongdataid_page8 <- srdata1
      defaultlongdataid_page8 <-defaultlongdataid_page8[!duplicated(defaultlongdataid_page8[[input$idvar_page8]]),]
    }
    return(defaultlongdataid_page8)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page8 <- renderUI({
    req(input$idvar_page8)
    tagList(
      selectInput("pid_page88", "Subject ID", choices=defaultlongdataid_page8()[[input$idvar_page8]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page8(), {
    updateSelectInput(session, "timevar_page8", choices = names(defaultlongdata_page8()))
    updateSelectInput(session, "visit_page8", choices = names(defaultlongdata_page8()))
  })
  output$selected_var_page8 <- reactive({
    
    if (input$data_option_page8 == "default") {
      req(input$pid_page8)
      paste("You have selected subject ID", input$pid_page8)
    } else {
      req(input$pid_page88)
      paste("Uploaded data selected with subject ID",input$pid_page88)
    }
  })
  
  output$selectedID_page8 <- reactive({
    if (input$data_option_page8 == "default") {
      req(input$pid_page8)
      paste('Prediction of marginal effect using model fitted through SIPW() for the selected subject ID: ',input$pid_page8)
    } else {
      req(input$pid_page88)
      paste('Prediction of marginal effect using lmeaipw() for the selected subject ID: ',input$pid_page88)
    }
  })
  rv_page8<-reactiveValues(model_page8=NULL)
  
  
  observeEvent(input$submit_page8,{
    # Load default data
    output$summarymodel_page8 <- renderPrint({
      req(input$analysismodel_page8)
      req(input$idvar_page8)
      req(input$visit_page8)
      req(input$timevar_page8)
      #req(input$nimp_page8)
      req(input$corstr_page8)
      req(input$maxit_page8)
      req(input$family_page8)
      
      pMat_page8<-mice::make.predictorMatrix(defaultlongdata_page8()[names(defaultlongdata_page8())%in%all.vars(as.formula(input$analysismodel_page8))])
      
      fitmodel_page88 <- miAIPW1(data= defaultlongdata_page8() ,
                                 formula= as.formula(input$analysismodel_page8),    
                                 id= input$idvar_page8,
                                 visit=input$visit_page8,
                                 family=input$family_page8,
                                 corstr=input$corstr_page8,
                                 maxit=input$maxit_page8,
                                 pMat=pMat_page8
      )
      rv_page8$model_page8<-fitmodel_page88
      list(beta=fitmodel_page88$beta,var.beta=fitmodel_page88$betaSand)
    })
    
  })
  
  observeEvent(input$submit_page8,{
    # Load default data
    output$predplot_page8 <- renderPlot({
      req(input$data_option_page8)
      if(input$data_option_page8 == "default"){
        req(input$analysismodel_page8)
        req(input$idvar_page8)
        req(input$visit_page8)
        req(input$pid_page8)
        req(input$timevar_page8)
        #req(input$nimp_page8)
        req(input$corstr_page8)
        req(input$maxit_page8)
        req(input$family_page8)
        req(input$by_page8)
        
        pred_sipw_page8<-predGEE(data=defaultlongdata_page8(),idnumber=input$pid_page8,idvar=input$idvar_page8,
                                      fittedObject = rv_page8$model_page8,time=input$timevar_page8,by=input$by_page8)
        predplotGEE(pred_sipw_page8,scatter=F)
        
      }else{
        req(input$analysismodel_page8)
        req(input$idvar_page8)
        req(input$visit_page8)
        req(input$pid_page88)
        req(input$timevar_page8)
        #req(input$nimp_page8)
        req(input$corstr_page8)
        req(input$maxit_page8)
        req(input$family_page8)
        req(input$by_page8)
        
        pred_sipw_page8<-predGEE(data=defaultlongdata_page8(),idnumber=input$pid_page88,idvar=input$idvar_page8,
                                      fittedObject = rv_page8$model_page8,time=input$timevar_page8,by=input$by_page8)
        predplotGEE(pred_sipw_page8,scatter=F)
      }
    })
  })
  
},
  options = list(height=1000,width="100%")
)
```



MeanScore
=====================================  
  
  Column {data-width=1000}
-------------------------------------
  
```{r}
shinyApp(
  ui_page9 <-fluidPage(
  
  titlePanel("meanscore"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page9", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default" = "default")),
      conditionalPanel(
        condition = "input.data_option_page9== 'default'",
        selectInput("pid_page9", "ID", choices=unique(srdata1$ID),selectize = FALSE,size=5)
      ),
      conditionalPanel(
        condition = "input.data_option_page9 == 'upload'",
        fileInput("lfile_page9", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page9")
      ),
      selectInput("idvar_page9", "ID variable", choices =NULL),
      selectInput("visit_page9","Visit time",choices=NULL),
      selectInput("timevar_page9", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page9", "Longitudinal data analysis model", value = "C6kine~ActivinRIB+ActivinRIIA+ActivinRIIAB+Adiponectin+AgRP+ALCAM"),
      selectInput("corstr_page9","Select correlation structure", choices=c("independence","exchangeable","AR-1","unstructured")),
      selectInput("family_page9","Family to which the distribution belongs",choices=c('gaussian')),
      #numericInput("nimp_page9", "Number of imputation", value = 1),
      numericInput('by_page9',"Interval length for prediction",value=10),
      numericInput("maxit_page9","Max number of iteration",value=10),
      actionButton("submit_page9", "Submit")
    ),
    mainPanel(
      p('meanscore(): a function specifically developed(If your dataset has missing value) for GEE model for longitudinal data. The model parameters are estimated using Meanscore estimating equation. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/MIIPW/index.html")),
      textOutput('selected_var_page9'),
      verbatimTextOutput('summarymodel_page9'),
      textOutput('selectedID_page9'),
      plotOutput('predplot_page9')
    )
  )
)

,
 server_page9 <- function(input, output, session) {
  defaultlongdata_page9 <- reactive({
    if (input$data_option_page9 == 'upload') {
      req(input$lfile_page9)
      defaultlongdata_page9 <- read.csv(input$lfile_page9$datapath)
    } else {
      defaultlongdata_page9 <- srdata1
    }
    return(defaultlongdata_page9)
  })
  
  observeEvent(defaultlongdata_page9(), {
    updateSelectInput(session, "idvar_page9", choices = names(defaultlongdata_page9()))
  })
  defaultlongdataid_page9 <- reactive({
    if (input$data_option_page9 == 'upload') {
      req(input$lfile_page9)
      req(input$idvar_page9)
      defaultlongdataid_page9 <- read.csv(input$lfile_page9$datapath)
      defaultlongdataid_page9 <-defaultlongdataid_page9[!duplicated(defaultlongdataid_page9[[input$idvar_page9]]),]
    } else {
      defaultlongdataid_page9 <- srdata1
      defaultlongdataid_page9 <-defaultlongdataid_page9[!duplicated(defaultlongdataid_page9[[input$idvar_page9]]),]
    }
    return(defaultlongdataid_page9)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page9 <- renderUI({
    req(input$idvar_page9)
    tagList(
      selectInput("pid_page99", "Subject ID", choices=defaultlongdataid_page9()[[input$idvar_page9]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page9(), {
    updateSelectInput(session, "timevar_page9", choices = names(defaultlongdata_page9()))
    updateSelectInput(session, "visit_page9", choices = names(defaultlongdata_page9()))
  })
  output$selected_var_page9 <- reactive({
    
    if (input$data_option_page9 == "default") {
      req(input$pid_page9)
      paste("You have selected subject ID", input$pid_page9)
    } else {
      req(input$pid_page99)
      paste("Uploaded data selected with subject ID",input$pid_page99)
    }
  })
  
  output$selectedID_page9 <- reactive({
    if (input$data_option_page9 == "default") {
      req(input$pid_page9)
      paste('Prediction of marginal effect using model fitted through meanscore() for the selected subject ID: ',input$pid_page9)
    } else {
      req(input$pid_page99)
      paste('Prediction of marginal effect using meanscore() for the selected subject ID: ',input$pid_page99)
    }
  })
  rv_page9<-reactiveValues(model_page9=NULL)
  
  
  observeEvent(input$submit_page9,{
    # Load default data
    output$summarymodel_page9 <- renderPrint({
      req(input$analysismodel_page9)
      req(input$idvar_page9)
      req(input$visit_page9)
      req(input$timevar_page9)
      #req(input$nimp_page9)
      req(input$corstr_page9)
      req(input$maxit_page9)
      req(input$family_page9)
      
      pMat_page9<-mice::make.predictorMatrix(defaultlongdata_page9()[names(defaultlongdata_page9())%in%all.vars(as.formula(input$analysismodel_page9))])
      
      fitmodel_page99 <- MeanScore1(data= defaultlongdata_page9() ,
                                 formula= as.formula(input$analysismodel_page9),    
                                 id= input$idvar_page9,
                                 visit=input$visit_page9,
                                 family=input$family_page9,
                                 corstr=input$corstr_page9,
                                 maxit=input$maxit_page9,
                                 pMat=pMat_page9
      )
      rv_page9$model_page9<-fitmodel_page99
      list(beta=fitmodel_page99$beta,var.beta=fitmodel_page99$betaSand)
    })
    
  })
  
  observeEvent(input$submit_page9,{
    # Load default data
    output$predplot_page9 <- renderPlot({
      req(input$data_option_page9)
      if(input$data_option_page9 == "default"){
        req(input$analysismodel_page9)
        req(input$idvar_page9)
        req(input$visit_page9)
        req(input$pid_page9)
        req(input$timevar_page9)
        #req(input$nimp_page9)
        req(input$corstr_page9)
        req(input$maxit_page9)
        req(input$family_page9)
        req(input$by_page9)
        
        pred_sipw_page9<-predGEE(data=defaultlongdata_page9(),idnumber=input$pid_page9,idvar=input$idvar_page9,
                                      fittedObject = rv_page9$model_page9,time=input$timevar_page9,by=input$by_page9)
        predplotGEE(pred_sipw_page9,scatter=F)
        
      }else{
        req(input$analysismodel_page9)
        req(input$idvar_page9)
        req(input$visit_page9)
        req(input$pid_page99)
        req(input$timevar_page9)
        #req(input$nimp_page9)
        req(input$corstr_page9)
        req(input$maxit_page9)
        req(input$family_page9)
        req(input$by_page9)
        
        pred_sipw_page9<-predGEE(data=defaultlongdata_page9(),idnumber=input$pid_page99,idvar=input$idvar_page9,
                                      fittedObject = rv_page9$model_page9,time=input$timevar_page9,by=input$by_page9)
        predplotGEE(pred_sipw_page9,scatter=F)
      }
    })
  })
  
},
  options = list(height=1000,width="100%")
)
```

