---
title: "lmeMIIPW"
output: 
  flexdashboard::flex_dashboard:
  social: menu
source_code: embeded
runtime: shiny    
---

```{r setup, include=FALSE}
library(flexdashboard)
library(Matrix)
library(shiny)
library(JMbayes2)
library(MASS)
library(nlme)
library(insight)
library(spatstat)
library(numDeriv)
#library(MIIPW)
library(stats)
library(lme4)
library(dplyr)
library(ggplot2)
data('pbc2')
pbc2$alkaline<-log(pbc2$alkaline)
pbc2$sex<-factor(pbc2$sex,levels = c('male','female'),labels = c(1,0))
pbc2$sex<-as.numeric(as.character(pbc2$sex))
pbc2$drug<-factor(pbc2$drug,levels=c("placebo","D-penicil"),labels=c(1,0))
pbc2$drug<-as.numeric(as.character(pbc2$drug))
pbc2$id<-as.numeric(as.character(pbc2$id))


predLME<-function(newdata,fittedObject,time,by,timevalue=NULL){
  data<-newdata
  if(!fittedObject$Method%in%c('lmeaipw','lmeipw','lmemeanscore')){
    stop('method not included')
  }
  ana.model<-as.formula(fittedObject$Call$analysis.model)
  ana.y<-newdata[all.vars(ana.model)[1]]
  ana.x<-newdata[all.vars(ana.model)[2]]
  ana.x<-cbind(intercept=1,ana.x)
  
  
  
  if(fittedObject$Method=='lmeaipw'||fittedObject$Method=='lmemeanscore'){
    imp.model<-as.formula(fittedObject$Call$imp.model)
    imp.x<-newdata[all.vars(nobars(imp.model))]
    imp.x<-cbind(intercept=1,imp.x)
    gammalist<-fittedObject$gammalist
    R.y<-is.na(ana.y)
    nimp<-dim(gammalist)[1]
    imputed.y<-list();imputed.ry<-list()
    for(i in 1:nimp){
      imputed.y[[i]]<-as.matrix(imp.x)%*%as.matrix(gammalist[i,],ncol=1)
      imputed.ry[[i]]<-apply(data.frame(R.y=R.y,imputed.y[[i]]),1,function(x){if(x[1]==1){
        x[2]
      }else{
        NA
      }})
    }
    imputed.ry<-Reduce('cbind',imputed.ry)
    colnames(imputed.ry)<-paste0('yImp',paste0('.',1:nimp))
    imputed.anayx<-cbind(ana.x,Response=ana.y,imputed.ry)
    maxtime<-max(newdata[[time]])
    
    # if(is.null(timevalue)){
    #   timeseq<-seq(from=max(newdata[[time]]),to=max(newdata[[time]])+9*0.5,by=0.05)
    # }else{
    #   timeseq<-timevalue
    # }
    if(is.null(timevalue)){
      timeseq<-seq(from=max(newdata[[time]]),by=by,length.out=20)
    }else{
      timeseq<-timevalue
    }
    
    startptime<-max(newdata[[time]])
    pseudorow<-Reduce('rbind',replicate(length(timeseq),imputed.anayx[dim(imputed.anayx)[1],],simplify = FALSE))
    pseudorow[time]<-timeseq
    imputed.yx<-rbind(imputed.anayx,pseudorow)
    imputed.yx[(dim(data)[1]+1):dim(imputed.yx)[1],(dim(ana.x)[2]+1):dim(imputed.anayx)[2]]<-NA
  }
  
  if(fittedObject$Method=='lmeipw'){
    gammalist<-NULL
    R.y<-is.na(ana.y)
    nimp<-1
    imputed.y<-list();imputed.ry<-list()
    for(i in 1:nimp){
      imputed.y[[i]]<-c(rep(NA,dim(data)[1]))
      imputed.ry[[i]]<-as.matrix(rep(NA,dim(data)[1]),ncol=1)
    }
    imputed.ry<-Reduce('cbind',imputed.ry)
    colnames(imputed.ry)<-paste0('yImp',paste0('.',1:nimp))
    imputed.anayx<-cbind(ana.x,Response=ana.y,imputed.ry)
    maxtime<-max(newdata[[time]])
    
    if(is.null(timevalue)){
      timeseq<-seq(from=max(newdata[[time]]),to=max(newdata[[time]])+9*0.5,by=0.05)
    }else{
      timeseq<-timevalue
    }
    startptime<-max(newdata[[time]])
    pseudorow<-Reduce('rbind',replicate(length(timeseq),imputed.anayx[dim(imputed.anayx)[1],],simplify = FALSE))
    pseudorow[time]<-timeseq
    imputed.yx<-rbind(imputed.anayx,pseudorow)
    imputed.yx[(dim(data)[1]+1):dim(imputed.yx)[1],(dim(ana.x)[2]+1):dim(imputed.anayx)[2]]<-NA
  }
  beta.x<-as.matrix(imputed.yx[,1:dim(ana.x)[2]])
  betafit<-fittedObject$beta
  betacovfit<-fittedObject$var.beta
  fitin<-beta.x%*%as.matrix(betafit,ncol=1)
  fitvar<-beta.x%*%betacovfit%*%t(beta.x)
  fitse<-sqrt(diag(fitvar))
  fitll<-fitin-1.96*fitse
  fitul<-fitin+1.96*fitse
  imputed.yx<-cbind(imputed.yx,fitll=fitll,fitin=fitin,fitul=fitul,fitse=fitse)
  names(imputed.yx)[names(imputed.yx)==all.vars(ana.model)[1]]<-all.vars(ana.model)[1]
  #colnames(imputed.yx)[-c(1:length(betafit))]<-c('fitll','fitin','fitul','fitse')
  result<-list()
  result$updateData<-imputed.yx
  result$maxTime<-maxtime
  result$startptime<-startptime
  result$timevar<-time
  result$R.y<-R.y
  result$response<-all.vars(ana.model)[1]
  result$method<-fittedObject$Method
  #result$analysisModel<-
  return(result)
  
}
predplotLME<-function(object){
  #object<-prmodel
  predictions_df<-object$updateData
  timevar<-object$timevar
  response<-object$response
  predictions_df<-as.data.frame(predictions_df)
  names(predictions_df)[which(names(predictions_df)==timevar)]<-'Time'
  names(predictions_df)[which(names(predictions_df)==response)]<-'Response'
  lasttime<-object$maxTime
  Ry<-c(object$R.y)
  
  
  predictions_dfbefore<-predictions_df[1:length(Ry),]
  predictions_dfafter<-predictions_df[-c(1:length(Ry)),]
  
  if(sum(Ry)!=0&!(object$method=='lmeipw')){
    result<- ggplot()+
      geom_point(data=predictions_dfbefore,aes(x=Time,y=Response))+
      geom_line(data=predictions_dfbefore,aes(x = Time , y = Response ),color = "red",linetype = 3)+
      geom_ribbon(data=predictions_dfafter,aes(y=fitin,ymin = fitll, ymax =fitul,x= Time ), fill = "blue", alpha = 0.5) +
      geom_line(data=predictions_dfafter,aes(y=fitin,x=Time),color="red")+# Confidence interval ribbon
      geom_vline(xintercept = object$maxTime, linetype = "dashed", color = "black")+
      #geom_point(aes(y = Response ), color = "brown") + 
      geom_point(data=predictions_dfbefore,aes(y=yImp.1,x=Time),color="green")+
      geom_point(data=predictions_dfbefore,aes(y=yImp.2,x=Time),color="green")+
      geom_point(data=predictions_dfbefore,aes(y=yImp.3,x=Time),color="green")+# Observed data points
      labs(x = timevar, y = response, title = "Prediction using semparametric marginal model") +
      #scale_y_continuous(limits = c(0, 15))+
      theme(panel.background = element_rect(fill = "white", colour = "grey50"))
    
  }
  if(sum(Ry)==0||object$method=='lmeipw'){
    
    result<-ggplot()+
      geom_point(data=predictions_dfbefore,aes(x=Time,y=Response))+
      geom_line(data=predictions_dfbefore,aes(x = Time , y = Response ),color = "red",linetype = 3)+
      geom_ribbon(data=predictions_dfafter,aes(y=fitin,ymin = fitll, ymax =fitul,x= Time ), fill = "blue", alpha = 0.5) +
      geom_line(data=predictions_dfafter,aes(y=fitin,x=Time),color="red")+# Confidence interval ribbon
      geom_vline(xintercept = object$maxTime, linetype = "dashed", color = "black")+
      #geom_point(aes(y = Response ), color = "brown") + 
      #geom_point(data=predictions_dfbefore,aes(y=yImp.1,x=Time),color="green")+
      #geom_point(data=predictions_dfbefore,aes(y=yImp.2,x=Time),color="green")+
      #geom_point(data=predictions_dfbefore,aes(y=yImp.3,x=Time),color="green")+# Observed data points
      labs(x = timevar, y = response, title = "Prediction using semparametric marginal model") +
      #scale_y_continuous(limits = c(0, 15))+
      theme(panel.background = element_rect(fill = "white", colour = "grey50"))
    
  }
  #result<-suppressWarnings(result)
  suppressWarnings(print(result))
}
lmeaipw1<-function(data,M=5,id,
                   analysis.model,wgt.model,imp.model,
                   qpoints=4,
                   psiCov,nu,psi,
                   sigma=NULL,sigmaMiss,sigmaR,dist,link,
                   conv=.0001,maxiter,maxpiinv=-1,
                   se=TRUE,verbose=FALSE){
  # assumes independent normally-distributed random intercepts only, two-level data
  #library(spatstat)
  
  arg_checks <- as.list(match.call())[-1]
  arg_checks$analysis.model <-deparse(analysis.model)
  arg_checks$wgt.model<-deparse(wgt.model)
  arg_checks$imp.model<-deparse(imp.model)
  #arg_checks$psiCov<-
  
  if(is.null(data)){
    stop('data cannot be null, provide dataset which is used
         in the response model as well as in the working model')
  }
  if(is.null(id)){
    stop('id cannot be null, provide a longitudinal data
         with individual identification number')
  }
  if(is.null(analysis.model)){
    stop('provide an analysis model')
  }
  
  if(is.null(imp.model)){
    stop('provide an imputation model')
  }
  if(is.null(wgt.model)){
    stop('provide a weight model')
  }
  if(is.null(psiCov)||is.null(nu)||is.null(psi)||is.null(sigmaR)||is.null(sigmaMiss)){
    stop('provide working model parameters')
  }
  if(is.null(dist)||is.null(link)){
    stop('provide distribution and link function compatible with the data provided')
  }
  if(id%in%names(data)){
    names(data)[which(names(data)==id)]<-'id'
  }
  #match(c('formula', 'data', 'weights'), names(mf),0L)
  data<-data
  dist<-dist
  link<-link
  gammaCov<-psiCov
  alpha<-nu
  gamma<-psi
  sigma<-sigma
  tau<-sigmaR
  phi<-sigmaMiss
  
  analysis.var<-all.vars(analysis.model)
  wgt.var<-all.vars(nobars(wgt.model))
  imp.var<-all.vars(nobars(imp.model))
  
  if(sum(analysis.var%in%names(data))!=length(analysis.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  if(sum(wgt.var%in%names(data))!=length(wgt.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  if(sum(imp.var%in%names(data))!=length(imp.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  
  y<-data[,analysis.var[1]]
  x<-as.matrix(cbind(1,data[,c(analysis.var[-1])]))
  z.r<-data[,c(wgt.var)]
  z.y<-data[,c(imp.var)]
  n<-nrow(data)
  m<-length(unique(data$id))
  nj<-as.data.frame(table(data$id))$Freq
  # ASSIGN VARIABLES
  id<-rep(1:m,times=nj)
  r<-1*!is.na(y)
  covars.r<-cbind(intercept=rep(1,n),z.r);covars.r<-as.matrix(covars.r)
  covars.y<-cbind(intercept=rep(1,n),z.y);covars.y<-as.matrix(covars.y)
  p<-c(ncol(x),ncol(covars.r),ncol(covars.y))
  nj.obs<-aggregate(r~id,FUN=sum,data=data.frame(r,id))$r
  n.obs<-sum(r)
  sigma<-ifelse(sigma>=.0001,sigma,.0001); tau<-ifelse(tau>=.0001,tau,.0001); phi<-ifelse(phi>=.0001,phi,.0001)
  gammalist<-mvrnorm(n=M,mu=gamma,Sigma=gammaCov)
  if(dist=='gaussian'){	# link: identity
    obs.resid<-ifelse(r,(y-covars.y%*%gamma),0)
    obs.sq.resid<-obs.resid^2
    int.b<-(nj.obs/sigma+1/phi)^(-1)*aggregate(obs.resid~id,FUN=sum,data=data.frame(obs.resid,id))$obs.resid/sigma  # posterior expectation for b
    int.nulist<-list()
    for(i in 1:M){
      int.nulist[[i]]<-c(covars.y%*%as.vector(gammalist[i,]))+int.b[id]
    }
    int.nu<-Reduce('+',int.nulist)/M
  }
  if(verbose){print('Posterior Expectation of Nu'); print(summary(int.nu))}
  r.pdf<-function(a){
    r.pdf.each<-exp(r*(c(covars.r%*%alpha)+a))/(1+exp(c(covars.r%*%alpha)+a))
    return(aggregate(r.pdf.each~id,FUN=prod,data=data.frame(id,r.pdf.each))$r.pdf.each)
  }
  r.pdf.overpi<-function(a){
    invpi<-exp(-c(covars.r%*%alpha)-a)+1
    return(invpi*r.pdf(a)[id])
  }
  int.piinv<-gauss.hermite(r.pdf.overpi,mu=0,sd=sqrt(tau),order=qpoints)/gauss.hermite(r.pdf,mu=0,sd=sqrt(tau),order=qpoints)[id]   # posterior expectation for 1/pi
  trim=NULL; if(maxpiinv>0){trim=sum(int.piinv>maxpiinv); int.piinv[int.piinv>maxpiinv]=maxpiinv}		# trim inverse of pi to avoid extremely influential values
  if(verbose){print('Posterior Expectation of Inverse of Pi'); print(summary(int.piinv))}
  # NEWTON-RAPHSON TO ESTIMATE BETA FROM ESTIMATING EQUATIONS
  beta<-glm(y ~.-1, family=dist, data=cbind.data.frame(y,x))$coefficients
  nr.iter<-0;
  diff.nr<-100;
  while((max(abs(diff.nr))>conv)&(nr.iter<maxiter)){
    
    if(link=='identity'){
      mu.beta<-c(x%*%beta)
      dmu.beta<-x
      d2mu.beta<-matrix(0,n,p)
    }
    gij<-dmu.beta*c(ifelse(r,y*int.piinv-int.nu*int.piinv,0))+dmu.beta*int.nu-dmu.beta*mu.beta
    sm.beta<-colSums(gij)
    dsm.beta<-t(x)%*%(d2mu.beta*c(ifelse(r,y*int.piinv-int.nu*int.piinv,0))+int.nu-mu.beta)-t(dmu.beta)%*%dmu.beta
    beta.new<-as.vector(beta-solve(dsm.beta)%*%sm.beta)
    diff.nr<-beta.new-beta
    beta<-beta.new; remove(beta.new); nr.iter<-nr.iter+1;
    if(verbose){print('Newton-Raphson'); print(c(nr.iter,beta))}
  }
  if(max(abs(diff.nr))>conv){print(paste0('WARNING: Newton-Raphson algorithm did not converge. Maximum absolute change in parameter estimates at the last iteration was ',max(abs(diff.nr))))}
  SE<-function(beta,alpha,gamma,sigma,tau,phi){
    #library(spatstat)
    # FUNCTION TO ESTIMATE ASYMPTOTIC COVARIANCE MATRIX
    # derivatives for g_ij
    g<-function(alpha,gamma,sigma,tau,phi){
      
      sigma<-ifelse(sigma>=.0001,sigma,.0001); tau=ifelse(tau>=.0001,tau,.0001); phi=ifelse(phi>=.0001,phi,.0001)
      
      # ESTIMATE INTEGRALS FROM ESTIMATING EQUATIONS USING GAUSS-HERMITE QUADRATURE
      if(dist=='gaussian'){	# link: identity
        obs.resid<-ifelse(r,(y-covars.y%*%gamma),0)
        obs.sq.resid<-obs.resid^2
        int.b<-(nj.obs/sigma+1/phi)^(-1)*aggregate(obs.resid~id,FUN=sum,data=data.frame(obs.resid,id))$obs.resid/sigma  # posterior expectation for b
        int.nulist<-list()
        for(i in 1:M){
          int.nulist[[i]]<-c(covars.y%*%as.vector(gammalist[i,]))+int.b[id]
        }
        int.nu=Reduce('+',int.nulist)/M
      }
      
      if(dist=='binomial'){
        y.pdf<-function(b){
          y.pdf.each<-ifelse(r,exp(y*(c(covars.y%*%gamma)+b))/(1+exp(c(covars.y%*%gamma)+b)),1)
          return(aggregate(y.pdf.each~id,FUN=prod,data=data.frame(id,y.pdf.each))$y.pdf.each)
        }
        y.pdf.nu<-function(b){
          nu<-1/(exp(-c(covars.y%*%gamma)-b)+1)
          return(nu*y.pdf(b)[id])
        }
        int.nu<-gauss.hermite(y.pdf.nu,mu=0,sd=sqrt(phi),order=qpoints)/gauss.hermite(y.pdf,mu=0,sd=sqrt(phi),order=qpoints)[id]
      }
      
      r.pdf<-function(a){
        r.pdf.each<-exp(r*(c(covars.r%*%alpha)+a))/(1+exp(c(covars.r%*%alpha)+a))
        return(aggregate(r.pdf.each~id,FUN=prod,data=data.frame(id,r.pdf.each))$r.pdf.each)
      }
      r.pdf.overpi<-function(a){
        invpi<-exp(-c(covars.r%*%alpha)-a)+1
        return(invpi*r.pdf(a)[id])
      }
      int.piinv<-gauss.hermite(r.pdf.overpi,mu=0,sd=sqrt(tau),order=qpoints)/gauss.hermite(r.pdf,mu=0,sd=sqrt(tau),order=qpoints)[id]
      
      
      if(link=='identity'){
        mu.beta<-c(x%*%beta)
        dmu.beta<-x
        d2mu.beta<-matrix(0,n,p)
      }
      if(link=='logit'){
        mu.beta<-1/(exp(-c(x%*%beta))+1)
        dmu.beta<-x*exp(-c(x%*%beta))/(exp(-c(x%*%beta))+1)^2
        d2mu.beta<-x*exp(-c(x%*%beta))/(exp(-c(x%*%beta))+1)^3
      }
      
      gij<-dmu.beta*c(ifelse(r,y*int.piinv-int.nu*int.piinv,0))+dmu.beta*int.nu-dmu.beta*mu.beta
      return(apply(gij,2,sum)/m)
    }
    env.g<-new.env()
    assign("alpha", alpha, envir = env.g)
    assign("gamma", gamma, envir = env.g)
    assign("sigma", sigma, envir = env.g)
    assign("tau", tau, envir = env.g)
    assign("phi", phi, envir = env.g)
    if(dist=='gaussian'){
      d1.gij<-attr(numericDeriv(quote(g(alpha,gamma,sigma,tau,phi)), c('alpha','gamma','sigma','tau','phi'), env.g),'gradient')
      colnames(d1.gij)<-c(paste0(rep('alpha',p[2]),1:p[2]),paste0(rep('gamma',p[3]),1:p[3]),'sigma','tau','phi')
    }
    if(dist=='binomial'){
      d1.gij<-attr(numericDeriv(quote(g(alpha,gamma,sigma,tau,phi)), c('alpha','gamma','tau','phi'), env.g),'gradient')
      colnames(d1.gij)<-c(paste0(rep('alpha',p[2]),1:p[2]),paste0(rep('gamma',p[3]),1:p[3]),'tau','phi')
    }
    if(verbose){print('Derivative of gij')}
    
    l.alpha.tau.each<-function(alpha,tau){
      tau<-ifelse(tau>=.0001,tau,.0001)
      r.pdf<-function(a){
        r.pdf.each<-exp(r*(c(covars.r%*%alpha)+a))/(1+exp(c(covars.r%*%alpha)+a))
        return(aggregate(r.pdf.each~id,FUN=prod,data=data.frame(id,r.pdf.each))$r.pdf.each)
      }
      return(log(gauss.hermite(r.pdf,mu=0,sd=sqrt(tau),order=qpoints)))
    }
    l.alpha.tau<-function(parm){
      alpha<-parm[1:(p[2])]; tau=parm[p[2]+1]
      return(mean(l.alpha.tau.each(alpha,tau)))
    }
    env.l.alpha.tau<-new.env()
    assign("alpha", alpha, envir = env.l.alpha.tau)
    assign("tau", tau, envir = env.l.alpha.tau)
    d1l.alpha.tau<-attr(numericDeriv(quote(l.alpha.tau.each(alpha,tau)), c('alpha','tau'), env.l.alpha.tau),'gradient')   # 1st derivative of l_j(alpha,tau) for each cluster j=1,...,m
    if(verbose){print('1st Derivative of l(alpha,tau)')}
    
    d2l.alpha.tau<-hessian(l.alpha.tau,x=c(alpha,tau))
    colnames(d1l.alpha.tau)<-c(paste0(rep('alpha',p[2]),1:p[2]),'tau'); colnames(d2l.alpha.tau)=colnames(d1l.alpha.tau); rownames(d2l.alpha.tau)=colnames(d1l.alpha.tau)
    if(verbose){print('2nd Derivative of l(alpha,tau)')}
    if(dist=='gaussian'){
      l.gamma.phi.sigma.each<-function(gamma,phi,sigma){
        phi<-ifelse(phi>=.0001,phi,.0001)
        y.pdf<-function(b){
          y.pdf.each<-ifelse(r,exp(-(y-c(covars.y%*%gamma)-b)^2/(2*sigma))*(1/(sqrt(2*pi*sigma))),1)
          return(aggregate(y.pdf.each~id,FUN=prod,data=data.frame(id,y.pdf.each))$y.pdf.each)
        }
        return(log(gauss.hermite(y.pdf,mu=0,sd=sqrt(phi),order=qpoints)))
      }
      l.gamma.phi.sigma<-function(parm){
        gamma=parm[1:(p[3])]; phi=parm[p[3]+1]; sigma=parm[p[3]+2]
        return(mean(l.gamma.phi.sigma.each(gamma,phi,sigma)))
      }
      env.l.gamma.phi.sigma=new.env()
      assign("gamma", gamma, envir = env.l.gamma.phi.sigma)
      assign("phi", phi, envir = env.l.gamma.phi.sigma)
      assign("sigma", sigma, envir = env.l.gamma.phi.sigma)
      d1l.gamma.phi=attr(numericDeriv(quote(l.gamma.phi.sigma.each(gamma,phi,sigma)), c('gamma','phi','sigma'), env.l.gamma.phi.sigma),'gradient')
      d2l.gamma.phi=hessian(l.gamma.phi.sigma,x=c(gamma,phi,sigma))
      colnames(d1l.gamma.phi)=c(paste0(rep('gamma',p[3]),1:p[3]),'phi','sigma'); colnames(d2l.gamma.phi)=colnames(d1l.gamma.phi); rownames(d2l.gamma.phi)=colnames(d1l.gamma.phi)
    }
    if(dist=='binomial'){
      l.gamma.phi.each<-function(gamma,phi){
        phi<-ifelse(phi>=.0001,phi,.0001)
        y.pdf<-function(b){
          y.pdf.each<-ifelse(r,exp(y*(c(covars.y%*%gamma)+b))/(1+exp(c(covars.y%*%gamma)+b)),1)
          return(aggregate(y.pdf.each~id,FUN=prod,data=data.frame(id,y.pdf.each))$y.pdf.each)
        }
        return(log(gauss.hermite(y.pdf,mu=0,sd=sqrt(phi),order=qpoints)))
      }
      l.gamma.phi<-function(parm){
        gamma=parm[1:(p[3])]; phi=parm[p[3]+1]
        return(mean(l.gamma.phi.each(gamma,phi)))
      }
      env.l.gamma.phi=new.env()
      assign("gamma", gamma, envir = env.l.gamma.phi)
      assign("phi", phi, envir = env.l.gamma.phi)
      d1l.gamma.phi<-attr(numericDeriv(quote(l.gamma.phi.each(gamma,phi)), c('gamma','phi'), env.l.gamma.phi),'gradient')
      
      d2l.gamma.phi<-hessian(l.gamma.phi,x=c(gamma,phi))
      colnames(d1l.gamma.phi)<-c(paste0(rep('gamma',p[3]),1:p[3]),'phi'); colnames(d2l.gamma.phi)=colnames(d1l.gamma.phi); rownames(d2l.gamma.phi)=colnames(d1l.gamma.phi)
    }
    if(verbose){print('1st Derivative of l(gamma,phi)')}
    if(verbose){print('2nd Derivative of l(gamma,phi)')}
    
    # calculate covariance matrix for beta
    gj<-aggregate(gij~id,FUN=sum,data=data.frame(id,gij))[,2:(p[1]+1)]
    inside<-solve(dsm.beta)%*%(t(gj)-d1.gij[,grepl('alpha',colnames(d1.gij))|colnames(d1.gij)=='tau']%*%solve(d2l.alpha.tau)%*%t(d1l.alpha.tau)-d1.gij[,grepl('gamma',colnames(d1.gij))|colnames(d1.gij)=='sigma'|colnames(d1.gij)=='phi']%*%solve(d2l.gamma.phi)%*%t(d1l.gamma.phi))
    var.beta<-inside%*%t(inside)
    colnames(var.beta)<-c(paste0(rep('beta',p[1]),0:(p[1]-1))); rownames(var.beta)=colnames(var.beta)
    return(var.beta)
  }
  if(se==TRUE){var.beta<-SE(beta,alpha,gamma,sigma,tau,phi)}
  if(se==FALSE){var.beta=NULL}
  fitvalues<-c(as.matrix(x)%*%as.matrix(beta,ncol=1))
  gammalist<-gammalist
  result=list(Method="lmeaipw",Call=arg_checks,nr.conv=(max(abs(diff.nr))<=conv),
              nr.iter=nr.iter,nr.diff=max(abs(diff.nr)),beta=beta,var.beta=var.beta,fitvalues=fitvalues,gammalist=gammalist)
  return(result)
}
################################################################################
lmeipw1<-function(data,M=5,id,
                  analysis.model,wgt.model,
                  qpoints=4,
                  nu,
                  sigmaR,dist,link,
                  conv=.0001,maxiter,maxpiinv=-1,
                  se=TRUE,verbose=FALSE){
  #library(spatstat)
  arg_checks <- as.list(match.call())[-1]
  arg_checks$analysis.model <-deparse(analysis.model)
  arg_checks$wgt.model<-deparse(wgt.model)
  
  if(is.null(data)){
    stop('data cannot be null, provide dataset which is used
         in the response model as well as in the working model')
  }
  if(is.null(id)){
    stop('id cannot be null, provide a longitudinal data
         with individual identification number')
  }
  if(is.null(analysis.model)){
    stop('provide an analysis model')
  }
  
  if(is.null(wgt.model)){
    stop('provide a weight model')
  }
  if(is.null(nu)||is.null(sigmaR)){
    stop('provide working model parameters')
  }
  if(is.null(dist)||is.null(link)){
    stop('provide distribution and link function compatible with the data provided')
  }
  if(id%in%names(data)){
    names(data)[which(names(data)==id)]<-'id'
  }
  #match(c('formula', 'data', 'weights'), names(mf),0L)
  data<-data
  dist<-dist
  link<-link
  alpha<-nu
  tau<-sigmaR
  
  analysis.var<-all.vars(analysis.model)
  wgt.var<-all.vars(nobars(wgt.model))
  #imp.var<-all.vars(nobars(imp.model))
  
  if(sum(analysis.var%in%names(data))!=length(analysis.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  if(sum(wgt.var%in%names(data))!=length(wgt.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  
  y<-data[,analysis.var[1]]
  x<-as.matrix(cbind(1,data[,c(analysis.var[-1])]))
  z.r<-data[,c(wgt.var)]
  #z.y<-data[,c(imp.var)]
  n<-nrow(data)
  m<-length(unique(data$id))
  nj<-as.data.frame(table(data$id))$Freq
  id<-rep(1:m,times=nj)
  r<-1*!is.na(y)
  covars.r<-cbind(intercept=rep(1,n),z.r); covars.r<-as.matrix(covars.r)
  p<-c(ncol(x),ncol(covars.r),0)
  nj.obs<-aggregate(r~id,FUN=sum,data=data.frame(r,id))$r
  n.obs<-sum(r)
  tau<-ifelse(tau>=.0001,tau,.0001);
  
  r.pdf<-function(a){
    r.pdf.each<-exp(r*(c(covars.r%*%alpha)+a))/(1+exp(c(covars.r%*%alpha)+a))
    return(aggregate(r.pdf.each~id,FUN=prod,data=data.frame(id,r.pdf.each))$r.pdf.each)
  }
  r.pdf.overpi<-function(a){
    invpi<-exp(-c(covars.r%*%alpha)-a)+1
    return(invpi*r.pdf(a)[id])
  }
  int.piinv<-gauss.hermite(r.pdf.overpi,mu=0,sd=sqrt(tau),order=qpoints)/gauss.hermite(r.pdf,mu=0,sd=sqrt(tau),order=qpoints)[id]   # posterior expectation for 1/pi
  trim=NULL; if(maxpiinv>0){trim=sum(int.piinv>maxpiinv); int.piinv[int.piinv>maxpiinv]=maxpiinv}		# trim inverse of pi to avoid extremely influential values
  if(verbose){print('Posterior Expectation of Inverse of Pi'); print(summary(int.piinv))}
  
  # NEWTON-RAPHSON TO ESTIMATE BETA FROM ESTIMATING EQUATIONS
  beta<-glm(y ~.-1, family=dist, data=cbind.data.frame(y,x))$coefficients
  nr.iter<-0;
  diff.nr<-100;
  while((max(abs(diff.nr))>conv)&(nr.iter<maxiter)){
    
    if(link=='identity'){
      mu.beta<-c(x%*%beta)
      dmu.beta<-x
      d2mu.beta<-matrix(0,n,p)
    }
    
    gij<-dmu.beta*c(ifelse(r,(y-mu.beta)*int.piinv,0))
    sm.beta<-colSums(gij)
    dsm.beta<-t(x)%*%(d2mu.beta*c(ifelse(r,(y-mu.beta)*int.piinv,0)))-t(dmu.beta)%*%(dmu.beta*c(r*int.piinv))
    beta.new<-as.vector(beta-solve(dsm.beta)%*%sm.beta)
    diff.nr<-beta.new-beta
    beta=beta.new; remove(beta.new); nr.iter=nr.iter+1;
    if(verbose){print('Newton-Raphson'); print(c(nr.iter,beta))}
  }
  if(max(abs(diff.nr))>conv){print(paste0('WARNING: Newton-Raphson algorithm did not converge. Maximum absolute change in parameter estimates at the last iteration was ',max(abs(diff.nr))))}
  
  
  SE<-function(beta,alpha,tau){
    g<-function(alpha,tau){
      tau<-ifelse(tau>=.0001,tau,.0001);
      r.pdf<-function(a){
        r.pdf.each<-exp(r*(c(covars.r%*%alpha)+a))/(1+exp(c(covars.r%*%alpha)+a))
        return(aggregate(r.pdf.each~id,FUN=prod,data=data.frame(id,r.pdf.each))$r.pdf.each)
      }
      r.pdf.overpi<-function(a){
        invpi<-exp(-c(covars.r%*%alpha)-a)+1
        return(invpi*r.pdf(a)[id])
      }
      int.piinv<-gauss.hermite(r.pdf.overpi,mu=0,sd=sqrt(tau),order=qpoints)/gauss.hermite(r.pdf,mu=0,sd=sqrt(tau),order=qpoints)[id]
      if(link=='identity'){
        mu.beta<-c(x%*%beta)
        dmu.beta<-x
        d2mu.beta<-matrix(0,n,p)
      }
      if(link=='logit'){
        mu.beta<-1/(exp(-c(x%*%beta))+1)
        dmu.beta<-x*exp(-c(x%*%beta))/(exp(-c(x%*%beta))+1)^2
        d2mu.beta<-x*exp(-c(x%*%beta))/(exp(-c(x%*%beta))+1)^3
      }
      
      gij<-dmu.beta*c(ifelse(r,(y-mu.beta)*int.piinv,0))
      return(apply(gij,2,sum)/m)
    }
    env.g=new.env()
    assign("alpha", alpha, envir = env.g)
    assign("tau", tau, envir = env.g)
    if(dist=='gaussian'){
      d1.gij<-attr(numericDeriv(quote(g(alpha,tau)), c('alpha','tau'), env.g),'gradient')
      colnames(d1.gij)<-c(paste0(rep('alpha',p[2]),1:p[2]),'tau')
    }
    
    if(verbose){print('Derivative of gij')}
    l.alpha.tau.each<-function(alpha,tau){
      tau<-ifelse(tau>=.0001,tau,.0001)
      r.pdf<-function(a){
        r.pdf.each<-exp(r*(c(covars.r%*%alpha)+a))/(1+exp(c(covars.r%*%alpha)+a))
        return(aggregate(r.pdf.each~id,FUN=prod,data=data.frame(id,r.pdf.each))$r.pdf.each)
      }
      return(log(gauss.hermite(r.pdf,mu=0,sd=sqrt(tau),order=qpoints)))
    }
    l.alpha.tau<-function(parm){
      alpha=parm[1:(p[2])]; tau=parm[p[2]+1]
      return(mean(l.alpha.tau.each(alpha,tau)))
    }
    env.l.alpha.tau=new.env()
    assign("alpha", alpha, envir = env.l.alpha.tau)
    assign("tau", tau, envir = env.l.alpha.tau)
    d1l.alpha.tau<-attr(numericDeriv(quote(l.alpha.tau.each(alpha,tau)), c('alpha','tau'), env.l.alpha.tau),'gradient')
    if(verbose){print('1st Derivative of l(alpha,tau)')}
    d2l.alpha.tau<-hessian(l.alpha.tau,x=c(alpha,tau))
    colnames(d1l.alpha.tau)<-c(paste0(rep('alpha',p[2]),1:p[2]),'tau'); colnames(d2l.alpha.tau)=colnames(d1l.alpha.tau); rownames(d2l.alpha.tau)=colnames(d1l.alpha.tau)
    if(verbose){print('2nd Derivative of l(alpha,tau)')}
    # calculate covariance matrix for beta
    gj<-aggregate(gij~id,FUN=sum,data=data.frame(id,gij))[,2:(p[1]+1)]
    inside<-solve(dsm.beta)%*%(t(gj)-d1.gij[,grepl('alpha',colnames(d1.gij))|colnames(d1.gij)=='tau']%*%solve(d2l.alpha.tau)%*%t(d1l.alpha.tau))
    var.beta<-inside%*%t(inside)
    colnames(var.beta)<-c(paste0(rep('beta',p[1]),0:(p[1]-1))); rownames(var.beta)=colnames(var.beta)
    return(var.beta)
    
  }
  if(se==TRUE){var.beta<-SE(beta,alpha,tau)}
  if(se==FALSE){var.beta=NULL}
  fitvalues<-c(x%*%beta)
  #gammalist<-gammalist
  #result=list(Call=arg_checks,nr.conv=(max(abs(diff.nr))<=conv),
  #            nr.iter=nr.iter,nr.diff=max(abs(diff.nr)),beta=beta,var.beta=var.beta,fitvalues=fitvalues,gammalist=gammalist)
  
  
  result=list(Method="lmeipw",Call=arg_checks,nr.conv=(max(abs(diff.nr))<=conv),nr.iter=nr.iter,nr.diff=max(abs(diff.nr)),beta=beta,var.beta=var.beta,fitvalues=fitvalues)
  return(result)
}
################################################################################
lmemeanscore1<-function(data,M=5,id,analysis.model,imp.model,
                        qpoints=4,psiCov,psi,sigma=NULL,
                        sigmaMiss,dist,link,
                        conv=.0001,maxiter,
                        maxpiinv=-1,se=TRUE,verbose=FALSE){
  #library(spatstat)
  arg_checks <- as.list(match.call())[-1]
  arg_checks$analysis.model<-deparse(analysis.model)
  #arg_checks$wgt.model<-deparse(wgt.model)
  arg_checks$imp.model<-deparse(imp.model)
  if(is.null(data)){
    stop("data cannot be null, provide dataset which is used
         in the response model as well as in the working model")
  }
  if(is.null(id)){
    stop("id cannot be null, provide a longitudinal data
         with individual identificatio number")
  }
  if(is.null(analysis.model)){
    stop("provide an analysis model")
  }
  
  if(is.null(imp.model)){
    stop("provide an imputation model")
  }
  
  if(is.null(psi)||is.null(psiCov)||is.null(sigmaMiss)){
    stop("provide working model parameters")
  }
  if(is.null(dist)||is.null(link)){
    stop("provide distribution and link function compatible with the data provided")
  }
  if(id%in%names(data)){
    names(data)[which(names(data)==id)]<-'id'
  }
  #match(c('formula', 'data', 'weights'), names(mf),0L)
  data<-data
  dist<-dist
  link<-link
  gammaCov<-psiCov
  gamma<-psi
  sigma<-sigma
  phi<-sigmaMiss
  
  analysis.var<-all.vars(analysis.model)
  imp.var<-all.vars(nobars(imp.model))
  
  if(sum(analysis.var%in%names(data))!=length(analysis.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  
  
  if(sum(imp.var%in%names(data))!=length(imp.var)){
    stop('variables included in the models used should be in the dataset')
  }
  
  y<-data[,analysis.var[1]]
  x<-as.matrix(cbind(1,data[,c(analysis.var[-1])]))
  z.y<-data[,c(imp.var)]
  n<-nrow(data)
  m<-length(unique(data$id))
  nj<-as.data.frame(table(data$id))$Freq
  # ASSIGN VARIABLES
  id<-rep(1:m,times=nj)
  r<-1*!is.na(y)
  covars.y<-cbind(intercept=rep(1,n),z.y);covars.y<-as.matrix(covars.y)
  p<-c(ncol(x),0,ncol(covars.y))
  nj.obs<-aggregate(r~id,FUN=sum,data=data.frame(r,id))$r
  n.obs<-sum(r)
  sigma<-ifelse(sigma>=.0001,sigma,.0001);  phi<-ifelse(phi>=.0001,phi,.0001)
  gammalist<-mvrnorm(n=M,mu=gamma,Sigma=gammaCov)
  # ESTIMATE INTEGRALS FROM ESTIMATING EQUATIONS USING GAUSS-HERMITE QUADRATURE
  if(dist=='gaussian'){
    obs.resid<-ifelse(r,(y-covars.y%*%gamma),0)
    obs.sq.resid<-obs.resid^2
    int.b<-(nj.obs/sigma+1/phi)^(-1)*aggregate(obs.resid~id,FUN=sum,data=data.frame(obs.resid,id))$obs.resid/sigma
    int.nulist<-list()
    for(i in 1:M){
      int.nulist[[i]]<-c(covars.y%*%as.vector(gammalist[i,]))+int.b[id]
    }
    int.nu<-Reduce('+',int.nulist)/M
  }
  
  if(verbose){print('Posterior Expectation of Nu'); print(summary(int.nu))}
  trim=NULL
  
  # NEWTON-RAPHSON TO ESTIMATE BETA FROM ESTIMATING EQUATIONS
  beta<-glm(y ~.-1, family=dist, data=cbind.data.frame(y,x))$coefficients
  nr.iter<-0;
  diff.nr<-100;
  while((max(abs(diff.nr))>conv)&(nr.iter<maxiter)){
    
    if(link=='identity'){
      mu.beta<-c(x%*%beta)
      dmu.beta<-x
      d2mu.beta<-matrix(0,n,p)
    }
    
    gij<-dmu.beta*c(ifelse(r,y-int.nu,0))+dmu.beta*int.nu-dmu.beta*mu.beta
    sm.beta<-colSums(gij)
    dsm.beta<-t(x)%*%(d2mu.beta*c(ifelse(r,y-int.nu,0))+int.nu-mu.beta)-t(dmu.beta)%*%dmu.beta
    beta.new<-as.vector(beta-solve(dsm.beta)%*%sm.beta)
    diff.nr<-beta.new-beta
    beta=beta.new; remove(beta.new); nr.iter<-nr.iter+1;
    if(verbose){print('Newton-Raphson'); print(c(nr.iter,beta))}
  }
  if(max(abs(diff.nr))>conv){print(paste0('WARNING: Newton-Raphson algorithm did not converge. Maximum absolute change in parameter estimates at the last iteration was ',max(abs(diff.nr))))}
  
  SE<-function(beta,gamma,sigma,phi){
    g<-function(gamma,sigma,phi){
      sigma<-ifelse(sigma>=.0001,sigma,.0001);  phi<-ifelse(phi>=.0001,phi,.0001)
      if(dist=='gaussian'){	# link: identity
        obs.resid<-ifelse(r,(y-covars.y%*%gamma),0)
        obs.sq.resid<-obs.resid^2
        int.b<-(nj.obs/sigma+1/phi)^(-1)*aggregate(obs.resid~id,FUN=sum,data=data.frame(obs.resid,id))$obs.resid/sigma
        int.nulist<-list()
        for(i in 1:M){
          int.nulist[[i]]<-c(covars.y%*%as.vector(gammalist[i,]))+int.b[id]
        }
        int.nu<-Reduce('+',int.nulist)/M
      }
      if(link=='identity'){
        mu.beta<-c(x%*%beta)
        dmu.beta<-x
        d2mu.beta<-matrix(0,n,p)
      }
      if(link=='logit'){
        mu.beta<-1/(exp(-c(x%*%beta))+1)
        dmu.beta<-x*exp(-c(x%*%beta))/(exp(-c(x%*%beta))+1)^2
        d2mu.beta<-x*exp(-c(x%*%beta))/(exp(-c(x%*%beta))+1)^3
      }
      gij<-dmu.beta*c(ifelse(r,y-int.nu,0))+dmu.beta*int.nu-dmu.beta*mu.beta
      return(apply(gij,2,sum)/m)
    }
    env.g=new.env()
    assign("gamma", gamma, envir = env.g)
    assign("sigma", sigma, envir = env.g)
    assign("phi", phi, envir = env.g)
    if(dist=='gaussian'){
      d1.gij<-attr(numericDeriv(quote(g(gamma,sigma,phi)), c('gamma','sigma','phi'), env.g),'gradient')     # 1st derivative of E[within-cluster-sum(g_ij)]
      colnames(d1.gij)<-c(paste0(rep('gamma',p[3]),1:p[3]),'sigma','phi')
    }
    
    if(verbose){print('Derivative of gij')}
    
    # derivatives for l_j(gamma,phi)
    if(dist=='gaussian'){
      l.gamma.phi.sigma.each<-function(gamma,phi,sigma){
        phi<-ifelse(phi>=.0001,phi,.0001)
        y.pdf<-function(b){    # binary/Bernoulli distribution (logit link)
          y.pdf.each<-ifelse(r,exp(-(y-c(covars.y%*%gamma)-b)^2/(2*sigma))*(1/(sqrt(2*pi*sigma))),1)
          return(aggregate(y.pdf.each~id,FUN=prod,data=data.frame(id,y.pdf.each))$y.pdf.each)
        }
        return(log(gauss.hermite(y.pdf,mu=0,sd=sqrt(phi),order=qpoints)))
      }
      l.gamma.phi.sigma<-function(parm){
        gamma=parm[1:(p[3])]; phi=parm[p[3]+1]; sigma=parm[p[3]+2]
        return(mean(l.gamma.phi.sigma.each(gamma,phi,sigma)))
      }
      env.l.gamma.phi.sigma=new.env()
      assign("gamma", gamma, envir = env.l.gamma.phi.sigma)
      assign("phi", phi, envir = env.l.gamma.phi.sigma)
      assign("sigma", sigma, envir = env.l.gamma.phi.sigma)
      d1l.gamma.phi<-attr(numericDeriv(quote(l.gamma.phi.sigma.each(gamma,phi,sigma)), c('gamma','phi','sigma'), env.l.gamma.phi.sigma),'gradient')
      
      d2l.gamma.phi<-hessian(l.gamma.phi.sigma,x=c(gamma,phi,sigma))
      colnames(d1l.gamma.phi)<-c(paste0(rep('gamma',p[3]),1:p[3]),'phi','sigma'); colnames(d2l.gamma.phi)=colnames(d1l.gamma.phi); rownames(d2l.gamma.phi)=colnames(d1l.gamma.phi)
    }
    if(verbose){print('1st Derivative of l(gamma,phi)')}
    if(verbose){print('2nd Derivative of l(gamma,phi)')}
    gj<-aggregate(gij~id,FUN=sum,data=data.frame(id,gij))[,2:(p[1]+1)]
    inside<-solve(dsm.beta)%*%(t(gj)-d1.gij[,grepl('gamma',colnames(d1.gij))|colnames(d1.gij)=='sigma'|colnames(d1.gij)=='phi']%*%solve(d2l.gamma.phi)%*%t(d1l.gamma.phi))
    var.beta<-inside%*%t(inside)
    colnames(var.beta)<-c(paste0(rep('beta',p[1]),0:(p[1]-1))); rownames(var.beta)=colnames(var.beta)
    return(var.beta)
  }
  if(se==TRUE){var.beta<-SE(beta,gamma,sigma,phi)}
  if(se==FALSE){var.beta=NULL}
  fitvalues<-c(as.matrix(x)%*%as.matrix(beta,ncol=1))
  gammalist<-gammalist
  #result=list(Call=arg_checks,nr.conv=(max(abs(diff.nr))<=conv),
  #            nr.iter=nr.iter,nr.diff=max(abs(diff.nr)),beta=beta,var.beta=var.beta,fitvalues=fitvalues,gammalist=gammalist)
  
  
  result=list(Method='lmemeanscore',Call=arg_checks,nr.conv=(max(abs(diff.nr))<=conv),nr.iter=nr.iter,nr.diff=max(abs(diff.nr)),beta=beta,var.beta=var.beta,fitvalues=fitvalues,gammalist=gammalist)
  
  return(result)
  
}


```

# Introduction

## Column {data-width="1000"}

```{r}
shinyApp(
  ui_page1 <- fluidPage(
    titlePanel("MIIPW: An R package for longitudinal data model in the presence of incmplete observations"),
    sidebarLayout(
      sidebarPanel(
        h3("MIIPW"),
        h5("Developed by :"),
        h6("Atanu Bhattacharjee"),
        h6("Bhrigu Kumar Rajbongshi"),
        h6("Gajendra K Vishwakarma"),
        p('Download MIIPW package from'),
        a("https://cran.r-project.org/web/packages/MIIPW/index.html",
          href = "https://cran.r-project.org/web/packages/MIIPW/index.html")
      ),
      mainPanel(
        h3("Introduction"),
        p("MIIPW R package contains functions for data analysis of Repeated measurement using GEE. Data may contain missing value in response and covariates. For parameter estimation through Fisher Scoring algorithm, Mean Score and Inverse Probability Weighted method combining with Multiple Imputation are used when there is missing value in covariates/response. Mainly three functions are used here lmeipw(), lmeaipw() and lmemeanscore(). Separate mixed effect models for imputation and inverse probability weight are used in these function. For more details about mean score method, inverse probability weighted method see "),
        p("Bhattacharjee, A., Vishwakarma, G. K., Rajbongshi, B. K., & Tripathy, A. (2024). MIIPW: An R package for Generalized Estimating Equations with missing data integration using a combination of mean score and inverse probability weighted approaches and multiple imputation. Expert Systems with Applications, 238, 121973."),
        p("A short glimpse of the default dataset (PBC2 data set) we have used here is "),
         verbatimTextOutput('exampledatalong'),
        p("A scatter plot of alkaline~year (alkaline values are tranformed in log scale)"), 
        plotOutput('exampledatalong1'),
        p("To explore more about this we can use a visualiztion plot using naniar package"),
        plotOutput("missplot")
        
     
        
      )
    )
  ),
  server_page1 <- function(input, output, session) {
    output$exampledatalong <- renderPrint({
       #cat('First 10 rows of default Longitudinal data')
      pbc2[pbc2$id<=3,]
    })
    output$exampledatalong1<-renderPlot({
      
      
      meanpbc2 <-pbc2 %>% 
      group_by(id) %>% 
      mutate(visit=row_number())
        ggplot()+
        geom_point(data = pbc2, aes(x = year, y = alkaline, group = id))+
        #geom_point(data=pbc2,aes(x=year,y=alkaline),color=drug)+
        geom_line()
          
    })
    
    output$missplot<-renderPlot({
      naniar::vis_miss(pbc2[,-c(1:11,19,20)])
    })
    
  },
  options = list(height=1000,width="100%")
)
```

# lmeaipw

## Column {data-width="1000"}

```{r}
shinyApp(
  ui_page2 <- fluidPage(
  
  titlePanel("lmeaipw"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page2", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default(PBC2 data)" = "default")),
      conditionalPanel(
        condition = "input.data_option_page2== 'default'",
        selectInput("pid_page2", "ID", choices=unique(pbc2$id),selectize = FALSE,size=5 )
      ),
      conditionalPanel(
        condition = "input.data_option_page2 == 'upload'",
        fileInput("lfile_page2", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page2")
      ),
      selectInput("idvar_page2", "ID variable", choices =NULL),
      selectInput("timevar_page2", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page2", "Longitudinal data analysis model", value = "alkaline~year"),
      textInput("impmodel_page2", "Imputation model for missing response", value = "~year+age+sex+drug+serBilir+(1|id)"),
      textInput("wgtmodel_page2", "IPW model", value = "~year+age+sex+drug+serBilir+(1|id)"),
      numericInput('by_page2',"Interval length for prediction",value=1),
      numericInput("nimp_page2", "Number of imputation", value = 1),
      actionButton("submit_page2", "Submit")
    ),
    mainPanel(
      p('lmeaipw(): a function specifically developed(If your dataset donot have missing value. 
      Please donot use this...) for semiparametric marginal model for longitudinal data where
      there are missing values in response variable (currently we are considering Continuous/
      extension for other option will be done in future) of the analysis model. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/jmBIG/index.html")),
      
      verbatimTextOutput('summarymodel_page2'),
      textOutput('selected_var_page2'),
      textOutput('selectedID_page2'),
      plotOutput('predplot_page2')
    )
  )
),
  server_page2 <- function(input, output, session) {
  defaultlongdata_page2 <- reactive({
    if (input$data_option_page2 == 'upload') {
      req(input$lfile_page2)
      defaultlongdata_page2 <- read.csv(input$lfile_page2$datapath)
    } else {
      defaultlongdata_page2 <- pbc2
    }
    return(defaultlongdata_page2)
  })
  
  observeEvent(defaultlongdata_page2(), {
    updateSelectInput(session, "idvar_page2", choices = names(defaultlongdata_page2()))
  })
  defaultlongdataid_page2 <- reactive({
    if (input$data_option_page2 == 'upload') {
      req(input$lfile_page2)
      req(input$idvar_page2)
      defaultlongdataid_page2 <- read.csv(input$lfile_page2$datapath)
      defaultlongdataid_page2 <-defaultlongdataid_page2[!duplicated(defaultlongdataid_page2[[input$idvar_page2]]),]
    } else {
      defaultlongdataid_page2 <- pbc2
      defaultlongdataid_page2 <-defaultlongdataid_page2[!duplicated(defaultlongdataid_page2[[input$idvar_page2]]),]
    }
    return(defaultlongdataid_page2)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page2 <- renderUI({
    req(input$idvar_page2)
    tagList(
      selectInput("pid_page22", "Subject ID", choices=defaultlongdataid_page2()[[input$idvar_page2]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page2(), {
    updateSelectInput(session, "timevar_page2", choices = names(defaultlongdata_page2()))
  })
  output$selected_var_page2 <- reactive({
    
    if (input$data_option_page2 == "default") {
      req(input$pid_page2)
      paste("You have selected patient ID", input$pid_page2)
    } else {
      req(input$pid_page22)
      paste("Uploaded data selected with patient ID",input$pid_page22)
    }
  })
  
  output$selectedID_page2 <- reactive({
    if (input$data_option_page2 == "default") {
      req(input$pid_page2)
      paste('Prediction of marginal effect using lmeaipw() for the selected subject ID: ',input$pid_page2)
    } else {
      req(input$pid_page22)
      paste('Prediction of marginal effect using lmeaipw() for the selected subject ID: ',input$pid_page22)
    }
  })
  rv<-reactiveValues(model_page2=NULL)
  observeEvent(input$submit_page2,{
    # Load default data
    output$summarymodel_page2 <- renderPrint({
      req(input$analysismodel_page2)
      req(input$impmodel_page2)
      req(input$wgtmodel_page2)
      req(input$idvar_page2)
      req(input$nimp_page2)
      
      intval_page2<-function(){
        amodel_page2<-as.formula(input$analysismodel_page2)
        imodel_page2<-as.formula(input$impmodel_page2)
        wmodel_page2<-as.formula(input$wgtmodel_page2)
        newdata<-defaultlongdata_page2()
        r.ij<-ifelse(is.na(defaultlongdata_page2()[[all.vars(amodel_page2)[1]]])==T,0,1)
        newdata<-cbind.data.frame(newdata,r.ij)
        newdata<-cbind(r.ij=ifelse(is.na(newdata[[all.vars(amodel_page2)[1]]])==T,0,1),newdata)
        model.r<-glmer(as.formula(paste0('r.ij',input$wgtmodel_page2)),family=binomial(link='logit'),
                       data=newdata)
        model.y<-lmer(as.formula(paste0(all.vars(amodel_page2)[1],input$impmodel_page2)),data=na.omit(newdata))
        nu<-model.r@beta
        psi<-model.y@beta
        sigma<-get_variance_residual(model.y)
        sigmaR<-get_variance(model.r)$var.random
        sigmaMiss<-get_variance(model.y)$var.random
        result<-list()
        result$nu<-as.matrix(nu,ncol=1)
        result$psi<-as.matrix(psi,ncol=1)
        result$sigma<-sigma
        result$sigmaR<-sigmaR
        result$sigmaMiss<-sigmaMiss
        result$psiCov<-vcov(model.y)
        return(result)
      }
      
      intvalue_page2<-intval_page2()
      fitmodel_page22 <- lmeaipw1(data= defaultlongdata_page2() ,
                                  id= input$idvar_page2,
                                  analysis.model= as.formula(input$analysismodel_page2),
                                  wgt.model= as.formula(input$wgtmodel_page2),
                                  imp.model= as.formula(input$impmodel_page2),
                                  psiCov= intvalue_page2$psiCov,
                                  nu= intvalue_page2$nu,
                                  psi= intvalue_page2$psi,
                                  sigma= intvalue_page2$sigma,
                                  sigmaMiss= intvalue_page2$sigmaMiss,
                                  sigmaR= intvalue_page2$sigmaR,
                                  dist= 'gaussian',
                                  link= 'identity',
                                  maxiter= 200)
      rv$model_page2<-fitmodel_page22
      list(beta=fitmodel_page22$beta,var.beta=fitmodel_page22$var.beta)
    })
    
  })
  
   observeEvent(input$submit_page2,{
     # Load default data
     output$predplot_page2 <- renderPlot({
         req(input$data_option_page2)
       if(input$data_option_page2 == "default"){
         req(input$analysismodel_page2)
         req(input$impmodel_page2)
         req(input$wgtmodel_page2)
         req(input$idvar_page2)
         req(input$timevar_page2)
         req(input$nimp_page2)
         req(input$by_page2)
         req(input$pid_page2)
         modelfitplot<-rv$model_page2
         modeltimevar<-input$timevar_page2
         newdata<-defaultlongdata_page2()[defaultlongdata_page2()[[input$idvar_page2]]==input$pid_page2,]
         m22<-predLME(newdata = newdata,fittedObject = rv$model_page2,time=input$timevar_page2,by=input$by_page2)
         predplotLME(m22)
       }else{
         req(input$analysismodel_page2)
         req(input$impmodel_page2)
         req(input$wgtmodel_page2)
         req(input$idvar_page2)
         req(input$timevar_page2)
         req(input$nimp_page2)
         req(input$by_page2)
         req(input$pid_page22)
         modelfitplot<-rv$model_page2
         modeltimevar<-input$timevar_page2
         newdata<-defaultlongdata_page2()[defaultlongdata_page2()[[input$idvar_page2]]==input$pid_page22,]
         m22<-predLME(newdata = newdata,fittedObject = rv$model_page2,time=input$timevar_page2,by=input$by_page2)
         predplotLME(m22)
       }
     })
   })
},
  options = list(height=1000,width="100%")
)
```

# lmeipw

## Column {data-width="1000"}

```{r}
shinyApp(
  ui_page3 <- fluidPage(
  
  titlePanel("lmeipw"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page3", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default(PBC2 data)" = "default")),
      conditionalPanel(
        condition = "input.data_option_page3== 'default'",
        selectInput("pid_page3", "ID", choices=unique(pbc2$id),selectize = FALSE,size=5 )
      ),
      conditionalPanel(
        condition = "input.data_option_page3 == 'upload'",
        fileInput("lfile_page3", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page3")
      ),
      selectInput("idvar_page3", "ID variable", choices =NULL),
      selectInput("timevar_page3", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page3", "Longitudinal data analysis model", value = "alkaline~year"),
      textInput("impmodel_page3", "Imputation model for missing response", value = "~year+age+sex+drug+serBilir+(1|id)"),
      textInput("wgtmodel_page3", "IPW model", value = "~year+age+sex+drug+serBilir+(1|id)"),
      numericInput('by_page3',"Interval length for prediction",value=1),
      numericInput("nimp_page3", "Number of imputation", value = 1),
      actionButton("submit_page3", "Submit")
    ),
    mainPanel(
      p('lmeipw(): a function specifically developed(If your dataset donot have missing value. 
      Please donot use this...) for semiparametric marginal model for longitudinal data where
      there are missing values in response variable (currently we are considering Continuous/
      extension for other option will be done in future) of the analysis model. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/jmBIG/index.html")),
      
      verbatimTextOutput('summarymodel_page3'),
      textOutput('selected_var_page3'),
      textOutput('selectedID_page3'),
      plotOutput('predplot_page3')
    )
  )
)
,
  server_page3 <- function(input, output, session) {
  defaultlongdata_page3 <- reactive({
    if (input$data_option_page3 == 'upload') {
      req(input$lfile_page3)
      defaultlongdata_page3 <- read.csv(input$lfile_page3$datapath)
    } else {
      defaultlongdata_page3 <- pbc2
    }
    return(defaultlongdata_page3)
  })
  
  observeEvent(defaultlongdata_page3(), {
    updateSelectInput(session, "idvar_page3", choices = names(defaultlongdata_page3()))
  })
  defaultlongdataid_page3 <- reactive({
    if (input$data_option_page3 == 'upload') {
      req(input$lfile_page3)
      req(input$idvar_page3)
      defaultlongdataid_page3 <- read.csv(input$lfile_page3$datapath)
      defaultlongdataid_page3 <-defaultlongdataid_page3[!duplicated(defaultlongdataid_page3[[input$idvar_page3]]),]
    } else {
      defaultlongdataid_page3 <- pbc2
      defaultlongdataid_page3 <-defaultlongdataid_page3[!duplicated(defaultlongdataid_page3[[input$idvar_page3]]),]
    }
    return(defaultlongdataid_page3)
  })
  
  # Render PID slider for uploaded data
  output$pid_slider_upload_page3 <- renderUI({
    req(input$idvar_page3)
    tagList(
      selectInput("pid_page33", "Subject ID", choices=defaultlongdataid_page3()[[input$idvar_page3]],selectize = FALSE,size=5)
    )
  })
  
  observeEvent(defaultlongdata_page3(), {
    updateSelectInput(session, "timevar_page3", choices = names(defaultlongdata_page3()))
  })
  output$selected_var_page3 <- reactive({
    
    if (input$data_option_page3 == "default") {
      req(input$pid_page3)
      paste("You have selected patient ID", input$pid_page3)
    } else {
      req(input$pid_page33)
      paste("Uploaded data selected with patient ID",input$pid_page33)
    }
  })
  
  output$selectedID_page3 <- reactive({
    if (input$data_option_page3 == "default") {
      req(input$pid_page3)
      paste('Prediction of marginal effect using lmeipw() for the selected subject ID: ',input$pid_page3)
    } else {
      req(input$pid_page33)
      paste('Prediction of marginal effect using lmeipw() for the selected subject ID: ',input$pid_page33)
    }
  })
  rv<-reactiveValues(model_page3=NULL)
  observeEvent(input$submit_page3,{
    # Load default data
    output$summarymodel_page3 <- renderPrint({
      req(input$analysismodel_page3)
      req(input$impmodel_page3)
      req(input$wgtmodel_page3)
      req(input$idvar_page3)
      req(input$nimp_page3)
      
      intval_page3<-function(){
        amodel_page3<-as.formula(input$analysismodel_page3)
        wmodel_page3<-as.formula(input$wgtmodel_page3)
        newdata<-defaultlongdata_page3()
        r.ij<-ifelse(is.na(defaultlongdata_page3()[[all.vars(amodel_page3)[1]]])==T,0,1)
        newdata<-cbind.data.frame(newdata,r.ij)
        newdata<-cbind(r.ij=ifelse(is.na(newdata[[all.vars(amodel_page3)[1]]])==T,0,1),newdata)
        model.r<-glmer(as.formula(paste0('r.ij',input$wgtmodel_page3)),family=binomial(link='logit'),
                       data=newdata)
        nu<-model.r@beta
        sigmaR<-get_variance(model.r)$var.random
        result<-list()
        result$nu<-as.matrix(nu,ncol=1)
        result$sigmaR<-sigmaR
        return(result)
      }
      
      intvalue_page3<-intval_page3()
      fitmodel_page33 <- lmeipw1(data= defaultlongdata_page3() ,
                                id= input$idvar_page3,
                                analysis.model= as.formula(input$analysismodel_page3),
                                wgt.model= as.formula(input$wgtmodel_page3),
                                nu= intvalue_page3$nu,
                                sigmaR= intvalue_page3$sigmaR,
                                dist= 'gaussian',
                                link= 'identity',
                                maxiter= 200)
      rv$model_page3<-fitmodel_page33
      list(beta=fitmodel_page33$beta,var.beta=fitmodel_page33$var.beta)
    })
    
  })
  
  observeEvent(input$submit_page3,{
    # Load default data
    output$predplot_page3 <- renderPlot({
      req(input$data_option_page3)
      if(input$data_option_page3 == "default"){
        req(input$analysismodel_page3)
        #req(input$impmodel_page3)
        req(input$wgtmodel_page3)
        req(input$idvar_page3)
        req(input$timevar_page3)
        #req(input$nimp_page3)
        req(input$by_page3)
        req(input$pid_page3)
        modelfitplot<-rv$model_page3
        modeltimevar<-input$timevar_page3
        newdata<-defaultlongdata_page3()[defaultlongdata_page3()[[input$idvar_page3]]==input$pid_page3,]
        m22<-predLME(newdata = newdata,fittedObject = rv$model_page3,time=input$timevar_page3,by=input$by_page3)
        predplotLME(m22)
      }else{
        req(input$analysismodel_page3)
        #req(input$impmodel_page3)
        req(input$wgtmodel_page3)
        req(input$idvar_page3)
        req(input$timevar_page3)
        #req(input$nimp_page3)
        req(input$by_page3)
        req(input$pid_page33)
        modelfitplot<-rv$model_page3
        modeltimevar<-input$timevar_page3
        newdata<-defaultlongdata_page3()[defaultlongdata_page3()[[input$idvar_page3]]==input$pid_page33,]
        m22<-predLME(newdata = newdata,fittedObject = rv$model_page3,time=input$timevar_page3,by=input$by_page3)
        predplotLME(m22)
      }
    })
  })
  
  
  
  
},
  options = list(height=1000,width="100%")
)
```

# lmemeanscore

## Column {data-width="1000"}

```{r}
shinyApp(
  ui_page4 <- fluidPage(
  titlePanel("lmemeanscore"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("data_option_page4", "Select data source:",
                   c("Upload your own dataset" = "upload",
                     "Use default(PBC2 data)" = "default")),
      conditionalPanel(
        condition = "input.data_option_page4== 'default'",
        selectInput("pid_page4", "ID", choices=unique(pbc2$id),selectize = FALSE,size=5)
      ),
      conditionalPanel(
        condition = "input.data_option_page4 == 'upload'",
        fileInput("lfile_page4", "Upload Longitudinal Data (CSV format)"),
        uiOutput("pid_slider_upload_page4")
      ),
      selectInput("idvar_page4", "ID variable", choices =NULL),
      selectInput("timevar_page4", "Time dependent covariate", choices = NULL),
      textInput("analysismodel_page4", "Longitudinal data analysis model", value = "alkaline~year"),
      textInput("impmodel_page4", "Imputation model for missing response", value = "~year+age+sex+drug+serBilir+(1|id)"),
      textInput("wgtmodel_page4", "IPW model", value = "~year+age+sex+drug+serBilir+(1|id)"),
      numericInput('by_page4',"Interval length for prediction",value=1),
      numericInput("nimp_page4", "Number of imputation", value = 1),
      actionButton("submit_page4", "Submit")
    ),
    mainPanel(
      p('lmemeanscore(): a function specifically developed(If your dataset donot have missing value. 
      Please donot use this...) for semiparametric marginal model for longitudinal data where
      there are missing values in response variable (currently we are considering Continuous/
      extension for other option will be done in future) of the analysis model. 
      For more information about the arguments of the function please look ',a("here.",href = "https://cran.r-project.org/web/packages/jmBIG/index.html")),
      
      verbatimTextOutput('summarymodel_page4'),
      textOutput('selected_var_page4'),
      textOutput('selectedID_page4'),
      plotOutput('predplot_page4')
    )
  )
)
,
 server_page4 <- function(input, output, session) {
  defaultlongdata_page4 <- reactive({
    if (input$data_option_page4 == 'upload') {
      req(input$lfile_page4)
      defaultlongdata_page4 <- read.csv(input$lfile_page4$datapath)
    } else {
      defaultlongdata_page4 <- pbc2
    }
    return(defaultlongdata_page4)
  })
  observeEvent(defaultlongdata_page4(), {
    updateSelectInput(session, "idvar_page4", choices = names(defaultlongdata_page4()))
  })
  defaultlongdataid_page4 <- reactive({
    if (input$data_option_page4 == 'upload') {
      req(input$lfile_page4)
      req(input$idvar_page4)
      defaultlongdataid_page4 <- read.csv(input$lfile_page4$datapath)
      defaultlongdataid_page4 <-defaultlongdataid_page4[!duplicated(defaultlongdataid_page4[[input$idvar_page4]]),]
    } else {
      defaultlongdataid_page4 <- pbc2
      defaultlongdataid_page4 <-defaultlongdataid_page4[!duplicated(defaultlongdataid_page4[[input$idvar_page4]]),]
    }
    return(defaultlongdataid_page4)
  })
  # Render PID slider for uploaded data
  output$pid_slider_upload_page4 <- renderUI({
    req(input$idvar_page4)
    tagList(
      selectInput("pid_page44", "Subject ID", choices=defaultlongdataid_page4()[[input$idvar_page4]],selectize = FALSE,size=5)
    )
  })
  observeEvent(defaultlongdata_page4(), {
    updateSelectInput(session, "timevar_page4", choices = names(defaultlongdata_page4()))
  })
  output$selected_var_page4 <- reactive({
    if (input$data_option_page4 == "default") {
      req(input$pid_page4)
      paste("You have selected patient ID", input$pid_page4)
    } else {
      req(input$pid_page44)
      paste("Uploaded data selected with patient ID",input$pid_page44)
    }
  })
  output$selectedID_page4 <- reactive({
    
    if (input$data_option_page4 == "default") {
      req(input$pid_page4)
      paste('Prediction of marginal effect using lmemeanscore() for the selected subject ID: ',input$pid_page4)
    } else {
      req(input$pid_page44)
      paste('Prediction of marginal effect using lmemeanscore() for the selected subject ID: ',input$pid_page44)
    }
  })
  rv<-reactiveValues(model_page4=NULL)
  observeEvent(input$submit_page4,{
    # Load default data
    output$summarymodel_page4 <- renderPrint({
      req(input$analysismodel_page4)
      req(input$impmodel_page4)
      req(input$wgtmodel_page4)
      req(input$idvar_page4)
      req(input$nimp_page4)
      intval_page4<-function(){
        amodel_page4<-as.formula(input$analysismodel_page4)
        imodel_page4<-as.formula(input$impmodel_page4)
        newdata<-defaultlongdata_page4()
        r.ij<-ifelse(is.na(defaultlongdata_page4()[[all.vars(amodel_page4)[1]]])==T,0,1)
        newdata<-cbind.data.frame(newdata,r.ij)
        newdata<-cbind(r.ij=ifelse(is.na(newdata[[all.vars(amodel_page4)[1]]])==T,0,1),newdata)
        model.y<-lmer(as.formula(paste0(all.vars(amodel_page4)[1],input$impmodel_page4)),data=na.omit(newdata))
        psi<-model.y@beta
        sigma<-get_variance_residual(model.y)
        sigmaMiss<-get_variance(model.y)$var.random
        result<-list()
        result$psi<-as.matrix(psi,ncol=1)
        result$sigma<-sigma
        result$sigmaMiss<-sigmaMiss
        result$psiCov<-vcov(model.y)
        return(result)
      }
      intvalue_page4<-intval_page4()
      fitmodel_page44 <- lmemeanscore1(data= defaultlongdata_page4() ,
                                  id= input$idvar_page4,
                                  analysis.model= as.formula(input$analysismodel_page4),
                                  imp.model= as.formula(input$impmodel_page4),
                                  psiCov= intvalue_page4$psiCov,
                                  psi= intvalue_page4$psi,
                                  sigma= intvalue_page4$sigma,
                                  sigmaMiss= intvalue_page4$sigmaMiss,
                                  dist= 'gaussian',
                                  link= 'identity',
                                  maxiter= 200)
      #remove(intvalue_page2,intval_page2)
      rv$model_page4<-fitmodel_page44
      #print(fitmodel_page22)
      list(beta=fitmodel_page44$beta,var.beta=fitmodel_page44$var.beta)
    })
  })
  observeEvent(input$submit_page4,{
    # Load default data
    output$predplot_page4 <- renderPlot({
      req(input$data_option_page4)
      if(input$data_option_page4 == "default"){
        req(input$analysismodel_page4)
        req(input$impmodel_page4)
        req(input$wgtmodel_page4)
        req(input$idvar_page4)
        req(input$timevar_page4)
        req(input$by_page4)
        req(input$nimp_page4)
        req(input$pid_page4)
        modelfitplot<-rv$model_page4
        modeltimevar<-input$timevar_page4
        newdata<-defaultlongdata_page4()[defaultlongdata_page4()[[input$idvar_page4]]==input$pid_page4,]
        m22<-predLME(newdata = newdata,fittedObject = rv$model_page4,time=input$timevar_page4,by=input$by_page4)
        predplotLME(m22)
      }else{
        req(input$analysismodel_page4)
        req(input$impmodel_page4)
        req(input$wgtmodel_page4)
        req(input$idvar_page4)
        req(input$timevar_page4)
        req(input$nimp_page4)
        req(input$by_page4)
        req(input$pid_page44)
        modelfitplot<-rv$model_page4
        modeltimevar<-input$timevar_page4
        newdata<-defaultlongdata_page4()[defaultlongdata_page4()[[input$idvar_page4]]==input$pid_page44,]
        m22<-predLME(newdata = newdata,fittedObject = rv$model_page4,time=input$timevar_page4,by=input$by_page4)
        predplotLME(m22)
      }
    })
  })
},
  options = list(height=1000,width="100%")
)
```

